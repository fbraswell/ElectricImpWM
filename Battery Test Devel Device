// Device code for Data Test
// server.log("---DEVICE START---");

// When the Imp comes out of deep sleep, it starts here
// log an ADC value each 10 sec, only tell the server each minute 
t <- time();
findMBaddr <- 0; // find MB address

const MBwrite = 1;
const MBread = 0;

const MBcoilON = 0xFF; // Most Significant Byte
const MBcoilOFF = 0x00;

const MBmotorON = 1; // turn pump motor on
const MBmotorOFF = 0; // turn pump motor off
const MBmotorCoilAddr = 0x01; 

// Quarts per Day Info
const MBqpdRegisterAddr = 0x03;
const MBrealNumberRegisters = 0x02;
const MBrealNumberBytes = 0x04;

// Modbus command codes
const MB_ReadCoil = 1;
const MB_ReadDiscreteInput = 2;
const MB_ReadHoldingRegister = 3;
const MB_ReadInputRegister = 4;
const MB_WriteSingleCoil = 5;
const MB_WriteSingleHoldingRegister = 6;
const MB_WriteMultipleCoils = 15;
const MB_WriteMultipleHoldingRegisters = 16;

const MODBUS = "modbus";

// MB address for devices
// if the addr is set to -1 later in the prog
// it means that there is no response - the
// device is not present
 MB_ADDR_TimeMark <- 0x10;
 MB_ADDR_PT500 <- 0x01;
 MB_ADDR_MPX <- 0x01;
 MB_ADDR_ICHEM <- 0x02;
 
// Model for MPX is 5
MB_MODEL_MPX <- 5;
// Model for PT-500 is 9
MB_MODEL_PT500 <- 9;
 
 // Variables used to determine which
 // Modbus devices are connected
 MB_ADDR_TimeMark_Found <- 0;
 MB_ADDR_PT500_Found <- 0;
 MB_ADDR_MPX_Found <- 0;
 MB_ADDR_ICHEM_Found <- 0;
 
 MB_timesfound <- -5;

// Time Mark controller registers
const MB_ONTIME = "MB_OnTime";
const MB_OFFTIME = "MB_OffTime";
const MB_TEMPSETPOINT = "MB_TempSetPoint";
const MB_QUARTSPERDAY = "MB_QuartsPerDay";
const MB_CYCLES = "MB_Cycles";
const MB_TEMPERATURE = "MB_Temperature";
const MB_PLUNGERSIZE = "MB_PlungerSize";
const MB_PINPOSITION = "MB_PinPosition";
const MB_MOTORSIZE = "MB_MotorSize";
const MB_BATTERYVOLTAGE = "MB_BatteryVoltage";
const MB_VERSIONNUMBER = "MB_VersionNumber";

const TM_ONSEC = "TM_onsec";
const TM_ONMIN = "TM_onmin";
const TM_ONHR = "TM_onhr";
const TM_OFFSEC = "TM_offsec";
const TM_OFFMIN = "TM_offmin";
const TM_OFFHR = "TM_offhr";

const PT500_MODEL = "PT500_model";
const PT500_PRESSURE_H2O = "PT500_pressure_h2o";
const PT500_TEMPC = "PT500_tempC";
const PT500_CALC = "PT500_calc";
const PT500_BATV = "PT500_batv";

const MPX_MODEL = "MPX_model";
const MPX_TOPDIST = "MPX_topdist";
const MPX_BOTDIST = "MPX_botdist";
const MPX_TEMPC = "MPX_tempC";
const MPX_TOPCALC = "MPX_topcalc";
const MPX_BOTCALC = "MPX_botcalc";

const ICHEM_MONTH = "ICHEM_month";
const ICHEM_DAY = "ICHEM_day";
const ICHEM_YEAR = "ICHEM_year";
const ICHEM_HOUR = "ICHEM_hour";
const ICHEM_MIN = "ICHEM_min";
const ICHEM_SEC = "ICHEM_sec";

// Voltage regulator control & constants
const REGULATOR_ON = 0x01;
const REGULATOR_OFF = 0x00;
const REGULATOR_DELAY = 0.25; // wait for sensor to power up

// Pump mode or transducer mode
// Pump mode reads Modbus
const NOT_CONFIGURED = -1;
const PUMP_MODE = 1;
const TRANSDUCER_MODE = 0; 

// constant strings
// Making these strings constants helps
// prevent memory leaks, because the 
// strings are not created over and over again.

const TABLEDATA = "tabledata";
const BOOTCOUNT = "bootcount";
const TIME = "time";
const SWITCH1 = "switch1";
const SWITCH2 = "switch2";
const VBAT = "vbat";
const RSSI = "rssi";
const MEMORY = "memory";
const TEMP = "temp";
const TEMP002 = "temp002";
const ANALOG002 = "analog002";
const LIGHTLEVEL = "lightlev";
const WAKEREASON = "wakewhy";

const METADATA = "metadata";
const SSID = "ssid";
const DEVID = "devid";
const IMPTYPE = "imptype";

// Imp002 pins
HW_Temp002 <- hardware.pinA; // temp sensor voltage on pin2 and on IMP002 pinA
HW_AnalogIn002 <- hardware.pinB; // second analog channel on IMP002 pinB
HW_Hall002 <- hardware.pinD;    // second Hall switch
HW_UART002 <- hardware.uart6E;  // UART channel for serial RS-232
HW_Wakeup <- hardware.pin1;

// Pump with Modbus Mode 
 HW_MBUart1 <- hardware.uart1289;
 HW_FlowCount <- hardware.pin1;
 HW_ModBusDir <- hardware.pin2;

HW_RegulatorCntl <- hardware.pin5; // common to both modes
HW_Analog1In <- hardware.pin7; // Analog channel 1

// Transducer only mode        
 HW_Switch1 <- hardware.pin1;
 HW_Switch2 <- hardware.pin2;
 HW_Temp <- hardware.pin8; // temp sensor voltage
 HW_BatV <- hardware.pin9; // battery voltage to Imp board

// Check for hi and lo conditions using hysteresis algorithm
// Analog channel 1
// Analog1Volts_hi <- 1.1; // High voltage
// Analog1Volts_lo <- 1.0; // Low voltage
    // Switch tells us if above the trigger or below
// Analog1Volts_switch <- 0; // switch starts at off

impErrorCodes <-
[
    // Description Code
    "no code 0", // code 0
    "Illegal Function code 1", // code 1
    "Illegal Data Value code 2", // code 2
    "Illegal Data Value code 3", // code 3
    "Slave Device Failure code 4", // code 4
    "no code 5", // code 5
    "Slave Device Busy code 6", // code 6
    "no code 7", // code 7
    "no code 8", // code 8
    "no code 9", // code 9
    "Gateway Path Unavailable code 10", // code 10
    "Gateway Target Device Failed to Respond code 11" // code 11
];

/*
Imp Wake Codes
Code    Description
    0   "The power was turned on"
    1   "A software reset took place"
    2   "An event timer fired"
    3   "Pulse detected on Wakeup Pin"
    4   "New Squirrel code downloaded"
    5   "Squirrel runtime error"
    6   "impOS update"
    7   "A snooze-and-retry event"
        // imp003 only
    8   "Hardware reset"
*/

XmitNow <- 0; // used to force Xmit to agent - starts false

// UART Communication example for the Modbus communication
// Transfer data from Imp uart, pins 1 CTS (not used by us), 2 RTS, 8 Tx, 9 Rx
// Data will be sent form the Imp to the Spark Fun RS-485 break-out board
// The board uses the RTS signal to control the direction of the data on 
// the RS-485 wires

// Send back Imp information
agent.on("getImpInfo", function(nouse)
{
        // Respond back with nv.meta which
        // contains the ImpID and Network Name
        // This request only comes if the device is running
        // but the agent has been reset
    server.log("Send back metadata");
    agent.send(METADATA, nv.meta);
}); // agent.on("getImpInfo"

agent.on("modem_write", function(str)
{
    server.log("##1#received str from Agent: "+str);
    HW_UART002.write("\n"+str+"\n"); // write string to port
});

agent.on("impControlVariables", function(vars)
{
    // Get the variables for sample period, xmit period and Imp mode
    
    nv.PUMP = vars.IMP_MODE; // Pump controller Module?
    nv.XMIT_PERIOD = vars.IMP_XMIT_PER; // Time between transmissions
    nv.SAMPLE_PERIOD = vars.IMP_SAMPLE_PER; // Time between samples
    
    nv.IMP_ANALOG1_THRESHOLD = vars.IMP_ANALOG1_THRESHOLD;
    nv.IMP_ANALOG1_RANGE = vars.IMP_ANALOG1_RANGE;
    
    // Calculate the high and low hysteresis values
    nv.Analog1Volts_hi = nv.IMP_ANALOG1_THRESHOLD + 0.5 * nv.IMP_ANALOG1_RANGE; // High voltage
    nv.Analog1Volts_lo = nv.IMP_ANALOG1_THRESHOLD - 0.5 * nv.IMP_ANALOG1_RANGE; // Low voltage
/*    
    server.log("---nv.PUMP: "+nv.PUMP+" nv.XMIT_PERIOD: "+nv.XMIT_PERIOD+" nv.SAMPLE_PERIOD: "+nv.SAMPLE_PERIOD+
                " nv.IMP_ANALOG1_THRESHOLD: "+nv.IMP_ANALOG1_THRESHOLD+
                " nv.IMP_ANALOG1_RANGE: "+nv.IMP_ANALOG1_RANGE+" nv.time: "+nv.time);
*/
}); // agent.on("impControlVariables"

// Receive a new quarts per day setpoint from agent
agent.on("newsetpoint", function(newsetpoint) 
{
//    server.log("^^^^^^^^^^^^^Setting QuartsPerDay to: " + newsetpoint);
    writeQuartsPerDay(newsetpoint); 
}); // agent.on("newsetpoint"

// Turn the Modbus pump motor on or off
function setMotorState(state) 
{
    if(state == MBmotorON)
    {
       return MBwriteSingleCoil(MB_ADDR_TimeMark, MBmotorCoilAddr, MBcoilON);
    } else // MBmotorOFF
    {
        return MBwriteSingleCoil(MB_ADDR_TimeMark, MBmotorCoilAddr, MBcoilOFF);
    }
}   // function setMotorState(state) 

function writeQuartsPerDay(value) 
{
    // hex string "10 06 00 03 41 28 00 00 F7 33"
    // Modbus address - 0x10
    // command - 0x06
    // register - 0x0003
    // data (32 bit float) 0x41280000
    // CRC 0xF733
    
        // Motor cannot be set to 0 using quarts per day
        // The minimum qpd value is 0.1 qpd, not quite 0
        // To turn the motor completely off, you must
        // use a different command to set the motor to off
    if (value.tofloat() > 0.1)
//        setMotorState(1);
        setMotorState(MBmotorON);
    else
//        setMotorState(0);
        setMotorState(MBmotorOFF);
    
    if (value.tofloat() > 0.1) 
    {
        local qpdCommand = [ 0x10, 0x10, 0x00, 0x03, 0x00, 0x02, 0x04 ];
        
        local flBlob = blob(4);
        flBlob.writen(value.tofloat(), 'f');
        
        qpdCommand.append(flBlob[3]);
        qpdCommand.append(flBlob[2]);
        qpdCommand.append(flBlob[1]);
        qpdCommand.append(flBlob[0]);
        
        // Quarts per Day Info
        // MBqpdRegisterAddr = 0x03;
        // MBrealNumberRegisters = 0x02;
        // MBrealNumberBytes = 0x04;
        // four bytes of data
        
        // Write multiple holding registers

        return MBwriteMultipleHoldingRegisters(
            MB_ADDR_TimeMark,
            MBqpdRegisterAddr,
            MBrealNumberRegisters, 
            MBrealNumberBytes, 
            // data array with number of bytes
            [flBlob[3], flBlob[2], flBlob[1], flBlob[0]]);  
    }
}   // writeQuartsPerDay(value)

// CRC calculation code below is needed for the Modbus
// data packages.
//*************************************************
//************ CRC Calculation Code ***************
//*************************************************

// blob of CRC values for highâ€“order byte
const auchCRCHi = "\x00\xC1\x81\x40\x01\xC0\x80\x41\x01\xC0\x80\x41\x00\xC1\x81\x40\x01\xC0\x80\x41\x00\xC1\x81\x40\x00\xC1\x81\x40\x01\xC0\x80\x41\x01\xC0\x80\x41\x00\xC1\x81\x40\x00\xC1\x81\x40\x01\xC0\x80\x41\x00\xC1\x81\x40\x01\xC0\x80\x41\x01\xC0\x80\x41\x00\xC1\x81\x40\x01\xC0\x80\x41\x00\xC1\x81\x40\x00\xC1\x81\x40\x01\xC0\x80\x41\x00\xC1\x81\x40\x01\xC0\x80\x41\x01\xC0\x80\x41\x00\xC1\x81\x40\x00\xC1\x81\x40\x01\xC0\x80\x41\x01\xC0\x80\x41\x00\xC1\x81\x40\x01\xC0\x80\x41\x00\xC1\x81\x40\x00\xC1\x81\x40\x01\xC0\x80\x41\x01\xC0\x80\x41\x00\xC1\x81\x40\x00\xC1\x81\x40\x01\xC0\x80\x41\x00\xC1\x81\x40\x01\xC0\x80\x41\x01\xC0\x80\x41\x00\xC1\x81\x40\x00\xC1\x81\x40\x01\xC0\x80\x41\x01\xC0\x80\x41\x00\xC1\x81\x40\x01\xC0\x80\x41\x00\xC1\x81\x40\x00\xC1\x81\x40\x01\xC0\x80\x41\x00\xC1\x81\x40\x01\xC0\x80\x41\x01\xC0\x80\x41\x00\xC1\x81\x40\x01\xC0\x80\x41\x00\xC1\x81\x40\x00\xC1\x81\x40\x01\xC0\x80\x41\x01\xC0\x80\x41\x00\xC1\x81\x40\x00\xC1\x81\x40\x01\xC0\x80\x41\x00\xC1\x81\x40\x01\xC0\x80\x41\x01\xC0\x80\x41\x00\xC1\x81\x40";
// blob of CRC values for lowâ€“order byte
const auchCRCLo = "\x00\xC0\xC1\x01\xC3\x03\x02\xC2\xC6\x06\x07\xC7\x05\xC5\xC4\x04\xCC\x0C\x0D\xCD\x0F\xCF\xCE\x0E\x0A\xCA\xCB\x0B\xC9\x09\x08\xC8\xD8\x18\x19\xD9\x1B\xDB\xDA\x1A\x1E\xDE\xDF\x1F\xDD\x1D\x1C\xDC\x14\xD4\xD5\x15\xD7\x17\x16\xD6\xD2\x12\x13\xD3\x11\xD1\xD0\x10\xF0\x30\x31\xF1\x33\xF3\xF2\x32\x36\xF6\xF7\x37\xF5\x35\x34\xF4\x3C\xFC\xFD\x3D\xFF\x3F\x3E\xFE\xFA\x3A\x3B\xFB\x39\xF9\xF8\x38\x28\xE8\xE9\x29\xEB\x2B\x2A\xEA\xEE\x2E\x2F\xEF\x2D\xED\xEC\x2C\xE4\x24\x25\xE5\x27\xE7\xE6\x26\x22\xE2\xE3\x23\xE1\x21\x20\xE0\xA0\x60\x61\xA1\x63\xA3\xA2\x62\x66\xA6\xA7\x67\xA5\x65\x64\xA4\x6C\xAC\xAD\x6D\xAF\x6F\x6E\xAE\xAA\x6A\x6B\xAB\x69\xA9\xA8\x68\x78\xB8\xB9\x79\xBB\x7B\x7A\xBA\xBE\x7E\x7F\xBF\x7D\xBD\xBC\x7C\xB4\x74\x75\xB5\x77\xB7\xB6\x76\x72\xB2\xB3\x73\xB1\x71\x70\xB0\x50\x90\x91\x51\x93\x53\x52\x92\x96\x56\x57\x97\x55\x95\x94\x54\x9C\x5C\x5D\x9D\x5F\x9F\x9E\x5E\x5A\x9A\x9B\x5B\x99\x59\x58\x98\x88\x48\x49\x89\x4B\x8B\x8A\x4A\x4E\x8E\x8F\x4F\x8D\x4D\x4C\x8C\x44\x84\x85\x45\x87\x47\x46\x86\x82\x42\x43\x83\x41\x81\x80\x40";
 
function calculateCRC ( puchMsg, usDataLen )
{
    //unsigned char *puchMsg ; // message to calculate CRC upon
    //unsigned short usDataLen ; // quantity of bytes in message
    local uchCRCHi = 0xFF ; // high byte of CRC initialized
    local uchCRCLo = 0xFF ; // low byte of CRC initialized
    local uIndex ; // will index into CRC lookup table
    local i = 0;
    while (usDataLen--)
    { // pass through message buffer
        uIndex = uchCRCLo ^ puchMsg[i] ; // calculate the CRC
        uchCRCLo = uchCRCHi ^ auchCRCHi[uIndex] ;
        uchCRCHi = auchCRCLo[uIndex] ;
        i++
    }
    return [uchCRCLo, uchCRCHi] ;
}   // function calculateCRC ( puchMsg, usDataLen )

//*************************************************

// read from MB channel
function readMB()
{
    HW_ModBusDir.write(MBread);
    imp.sleep(10.0/1000.0); // wait for response
    
    local byte = -1;
    // The a stands for all bytes but I didn't want to type it out so many times.
    local MBbytes = [];
        // Read MB register data from UART
    while ((byte = HW_MBUart1.read()) != -1)
    {
        MBbytes.append(byte); // add byte to end of array
        imp.sleep(100.0/1000.0);    // wait for next byte
    } 
    return MBbytes;
} // readMB()

// write to MB channel
function writeMB(MBarray)
{
    // calculate the crc error code
    local crc = calculateCRC(MBarray, MBarray.len());
    // attach crc to end of array
    MBarray.extend(crc);

    // set chip for write to MB
    HW_ModBusDir.write(MBwrite);
    // send each byte to MB device
    foreach(val in MBarray)
    {
        HW_MBUart1.write(val);
    }
    // need small delay to let bytes finish sending
//    imp.sleep(15.0/1000.0); // wait for response
    // Adjust the delay based on the number of bytes sent
//    imp.sleep( (MBarray.len() * 1.1) / 1000.0 );
    imp.sleep( (MBarray.len() * 1.3) / 1000.0 );
//    server.log("---write MB---");
} // writeMB(MBarray)


// qpdCommand = [ 0x10, 0x10, 0x00, 0x03, 0x00, 0x02, 0x04 ];
// Quarts per Day Info
// const MBqpdRegisterAddr = 0x03;
// const MBrealNumberRegisters = 0x02;
// const MBrealNumberBytes = 0x04;

// MBqpdRegisterAddr, 
// MBrealNumberRegisters, 
// MBrealNumberBytes, 
// dataArray

// Write multiple holding registers
function MBwriteMultipleHoldingRegisters(MBaddr,
            startAddr, numRegisters, numBytes, array)
{
    local MBcmd = [MBaddr, MB_WriteMultipleHoldingRegisters,
                    // Big Endian MSByte first
                    // assume for now, MSByte is 0
                    0, startAddr
                    // number of registers to send
                    0, numRegisters,
                    // the number of bytes
                    numBytes]

    // append array bytes onto end of MBcmd
    foreach(val in array)
    {
        MBcmd.append(val);
    }
    
    writeMB(MBcmd); // send MB data 
    return readMB();
} // function MBwriteMultipleHoldingRegisters()

// motorCommand = [ 0x10, 0x05, 0x00, 0x01, 0xFF, 0x00 ]; // motor on
// motorCommand = [ 0x10, 0x05, 0x00, 0x01, 0x00, 0x00 ]; // motor off

// Write single coil
function MBwriteSingleCoil(MBaddr, coilAddr, coilValue)
{
    local MBcmd = [MBaddr, MB_WriteSingleCoil,
                    // Big Endian MSByte first
                    // assume for now, MSByte is 0
                    0, coilAddr,
                    // the upper byte is the value
                    coilValue, 0];
    writeMB(MBcmd);
    return readMB();
} // function MBwriteSingleCoil()

// Read MB holding registers - code 3
// return the MB response

function MBreadInputRegisters(MBaddr, startAddr, endAddr)
{
        // MB command: MBaddr byte, MBcode byte, start addr word, end addr word
    // upper and lower bytes
    local ubs, lbs, ube, lbe;
    ubs = startAddr >> 8;
    lbs = startAddr & 0x00ff;
    ube = endAddr >> 8;
    lbe = endAddr & 0x00ff;
//    server.log("Input upper st "+ubs+"; lower st "+lbs+
//                "; upper end "+ube+"; lower end "+lbe);
    local MBcmd = [MBaddr, MB_ReadInputRegister
                    // Big Endian MSByte first
                    // assume for now, MSByte is 0
                    ubs, lbs, 
                    // 0, startAddr,
                    ube, lbe];
                    // 0, endAddr];
    writeMB(MBcmd); // send the command
        // read the response and return array
    return readMB();
} // function MBreadInputRegisters(MBaddr, startAddr, endAddr)

function MBreadHoldingRegisters(MBaddr, startAddr, endAddr)
{
        // MB command: MBaddr byte, MBcode byte, start addr word, end addr word
    // upper and lower bytes
    local ubs, lbs, ube, lbe;
    ubs = startAddr >> 8;
    lbs = startAddr & 0x00ff;
    ube = endAddr >> 8;
    lbe = endAddr & 0x00ff;
//    server.log("holding upper st "+ubs+"; lower st "+lbs+
//                "; upper end "+ube+"; lower end "+lbe);
    local MBcmd = [MBaddr, MB_ReadHoldingRegister
                    // Big Endian MSByte first
                    // assume for now, MSByte is 0
                    ubs, lbs, 
                    // 0, startAddr,
                    ube, lbe];
                    // 0, endAddr];
    writeMB(MBcmd); // send the command
        // read the response and return array
    return readMB();
} // function MBreadHoldingRegisters(MBaddr, startAddr, endAddr)

// Get Modbus holding register data & decode it
function logMB_TimeMark() 
{
    // If MB communication not working, quit trying after 
    // MB_timesfound tries
    if (MB_ADDR_TimeMark_Found < MB_timesfound) return;

    // The a stands for all bytes but I didn't want to type it out so many times.
    local a = [ ];
    a = MBreadHoldingRegisters(MB_ADDR_TimeMark, 0, 15);
    
    // Some of these are supposed to be unsigned.  Are those being read correctly?
    if (a.len() > 8) 
    {   
        MB_ADDR_TimeMark_Found++; // Found TM Modbus data
        // MB Data available in the array
        const TIME_MARK_JAN14 = "time_mark_jan14";
        agent.send(TIME_MARK_JAN14, a); // Send raw data to Agent
/*        foreach (key, val in a)
        {
            server.log("TM key: "+key+" val: "+val)
        }
*/      local tmversion = (a[29] << 24) | (a[30] << 16) | (a[31] << 8) | a[32];
        local onTime = (a[3] << 8) | a[4];
        local offTime = (a[5] << 8) | a[6]; 
        
        if(tmversion == 140127)
        {
        
        // Convert the quarts per day from binary to a float
        local qpd = blob(4);
        qpd.writen(a[12], 'b');
        qpd.writen(a[11], 'b');
        qpd.writen(a[10], 'b');
        qpd.writen(a[9], 'b');
        qpd.seek(0, 'b');
        local quartsPerDay = qpd.readn('f');

        nv.sensor[MB_QUARTSPERDAY] <- quartsPerDay;
        nv.sensor[MB_CYCLES] <- (a[13] << 24) | (a[14] << 16) | (a[15] << 8) | a[16];
        nv.sensor[MB_TEMPERATURE] <- (a[17] << 8) | a[18];
        
            // The battery voltage on an AC unit will always be 0
            // in that case, do not send
        local batvolts = casti2f((a[25] << 24) | (a[26] << 16) | (a[27] << 8) | a[28]); // not working
        if(batvolts) // only report if batvolts ne 0
        {
            nv.sensor[MB_BATTERYVOLTAGE] <- batvolts;
        }
        
        // These values rarely change, if ever
        // only report them at start-up time
        if(nv.bootcount == 0)
        {
                // send battery voltage to show it is working, even if 0
            nv.sensor[MB_BATTERYVOLTAGE] <- casti2f((a[25] << 24) | (a[26] << 16) | (a[27] << 8) | a[28]); // not working
            nv.sensor[MB_VERSIONNUMBER] <- (a[29] << 24) | (a[30] << 16) | (a[31] << 8) | a[32];
            nv.sensor[MB_ONTIME] <- onTime;
            nv.sensor[MB_OFFTIME] <- offTime;
            nv.sensor[MB_TEMPSETPOINT] <- (a[7] << 8) | a[8];
            nv.sensor[MB_PLUNGERSIZE] <- (a[19] << 8) | a[20];
            nv.sensor[MB_PINPOSITION] <- (a[21] << 8) | a[22];
            nv.sensor[MB_MOTORSIZE] <- (a[23] << 8) | a[24]
        }
        } else
        {
            // Time Mark new controller
/*            
const TM_ONSEC = "TM_onsec";
const TM_ONMIN = "TM_onmin";
const TM_ONHR = "TM_onhr";
const TM_OFFSEC = "TM_offsec";
const TM_OFFMIN = "TM_offmin";
const TM_OFFHR = "TM_offhr";
*/
            nv.sensor[TM_ONSEC] <- -3;
            nv.sensor[TM_ONMIN] <- -3;
            nv.sensor[TM_ONHR] <- -3;
            nv.sensor[TM_OFFSEC] <- -3;
            nv.sensor[TM_OFFMIN] <- -3;
            nv.sensor[TM_OFFHR] <- -3;
        }
    } else 
    {   // no data in MB array
        server.log("Can't read Time Mark MODBUS registers!");
        MB_ADDR_TimeMark_Found--; // Didn't find TM Modbus data
//        MB_ADDR_TimeMark = -1;
    }
} // function logMB_TimeMark() 
//*************************************************

// APG PT-500 Modbus Holding Registers Handler
function logMB_APG() 
{
    // If MB communication not working, quit trying after 
    // MB_timesfound tries
    if (MB_ADDR_PT500_Found < MB_timesfound) return;

    // The a stands for all bytes but I didn't want to type it out so many times.
    local a = [ ];
    a = MBreadHoldingRegisters(1, 400, 20);
    
    // Some of these are supposed to be unsigned.  Are those being read correctly?
    if (a.len() > 8) 
    {   
        MB_ADDR_PT500_Found++; // Found PT-500 Modbus data
        // MB Data available in the array
        server.log("-- APG data array length: "+a.len());
//        server.log(format("== APG Dev addr: %d; Units: %d; App type: %d; a[3]: %d", a[0], a[1], a[2], a[3]));   
        const MB_PT500_HREG = "MB_PT500_HREG";
        agent.send(MB_PT500_HREG, a);
//        foreach (key, val in a)
//        {
//            server.log("APG key: "+key+" val: "+val)
//        }
        
    } else 
    {   // no data in APG MB array
        server.log("Can't read APG MODBUS registers!");
        MB_ADDR_PT500_Found--; // Didn't find PT-500 Modbus data
    }
} // function logMB_APG() 

// APG PT-500 Modbus Input Registers Handler
function logMB_APG_ireg() 
{
    // If MB communication not working, quit trying after 
    // MB_timesfound tries
    if (MB_ADDR_PT500_Found < MB_timesfound) return;
//    local d = date(); 
    // The a stands for all bytes but I didn't want to type it out so many times.
    local a = [ ];
    a = MBreadInputRegisters(MB_ADDR_PT500, 298, 12);
    
    // Some of these are supposed to be unsigned.  Are those being read correctly?
    if (a.len() > 8) 
    {   
        
// Model for MPX is 5
// MB_MODEL_MPX <- 5;
// Model for PT-500 is 9
// MB_MODEL_PT500 <- 9;
        local model = (a[3] << 8) | a[4];
        if (model == MB_MODEL_PT500)
        {
            MB_ADDR_PT500_Found++; // Found PT-500 Modbus data
            // MB Data available in the array
//          server.log("-- APG ireg data array length: "+a.len());
//          server.log(format("== APG Dev addr: %d; Units: %d; App type: %d; a[3]: %d", a[0], a[1], a[2], a[3]));   
            const MB_PT500_IREG = "MB_PT500_IREG";
            agent.send(MB_PT500_IREG, a);
//           foreach (key, val in a)
//          {
 //            server.log("APG ireg key: "+key+" val: "+val)
//          }
/*                    
PT500 <- 
{
    PT500_MODEL = -1, once
    PT500_PRESSURE_H2O = -1, each time
    PT500_TEMPC = -1, each time
    PT500_CALC = -1, never
    PT500_BATV = -1 once
}                    
*/
            // These two are sent every time
            nv.sensor[PT500_PRESSURE_H2O] <- (a[5] << 8) | a[6];
            nv.sensor[PT500_TEMPC] <- (a[9] << 8) | a[10];
        
            if(nv.bootcount == 0)
            {
                // send these only at power-up
               nv.sensor[PT500_MODEL] <- (a[3] << 8) | a[4];
                nv.sensor[PT500_BATV] <- (a[21] << 8) | a[22];
                nv.sensor[PT500_CALC] <- (a[13] << 8) | a[14];
            }
        } else // if (model == MB_MODEL_PT500)
        {
            server.log("Can't find APG ireg MODBUS registers! Model = "+model);
            MB_ADDR_PT500_Found--; // Didn't find PT-500 Modbus data
        }
    } else // if (a.len() > 0) 
    {   // no data in APG MB array
        server.log("Can't read APG ireg MODBUS registers!");
        MB_ADDR_PT500_Found--; // Didn't find PT-500 Modbus data
    }
} // function logMB_APG_ireg() 

// APG MPX Magnetostrictive Modbus Input Registers Handler
function logMB_MPX_ireg() 
{
    // If MB communication not working, quit trying after 
    // MB_timesfound tries
    if (MB_ADDR_MPX_Found < MB_timesfound) return;
    // The a stands for all bytes but I didn't want to type it out so many times.
    local a = [ ];
    a = MBreadInputRegisters(MB_ADDR_MPX, 298, 8);
    
    // Some of these are supposed to be unsigned.  Are those being read correctly?
    if (a.len() > 8) 
    {   
// Model for MPX is 5
// MB_MODEL_MPX <- 5;
// Model for PT-500 is 9
// MB_MODEL_PT500 <- 9;
        local model = (a[3] << 8) | a[4];
        if (model == MB_MODEL_MPX)
        {
            MB_ADDR_MPX_Found++; // Found PT-500 Modbus data
            // MB Data available in the array
//            server.log("-- MPX ireg data array length: "+a.len());
            const MB_MPX_IREG = "MB_MPX_IREG";
            agent.send(MB_MPX_IREG, a);
//          foreach (key, val in a)
//          {
 //             server.log("MPX ireg key: "+key+" val: "+val)
//          }

/*
const MPX_MODEL = "MPX_model"; one time
const MPX_TOPDIST = "MPX_topdist"; each time
const MPX_BOTDIST = "MPX_botdist"; each time
const MPX_TEMPC = "MPX_tempC"; each time
const MPX_TOPCALC = "MPX_topcalc"; one time
const MPX_BOTCALC = "MPX_botcalc"; one time
*/
            // These two are sent every time
            nv.sensor[MPX_TOPDIST] <- (a[5] << 8) | a[6];
            nv.sensor[MPX_BOTDIST] <- (a[7] << 8) | a[8];
            nv.sensor[MPX_TEMPC] <- (a[9] << 8) | a[10];
        
            if(nv.bootcount == 0)
            {
                    // send these only at power-up
                nv.sensor[MPX_MODEL] <- (a[3] << 8) | a[4];
                nv.sensor[MPX_TOPCALC] <- (a[11] << 8) | (a[12] << 8) | (a[13] << 8) | a[14];
                nv.sensor[MPX_BOTCALC] <- (a[15] << 8) | (a[16] << 8) | (a[17] << 8) | a[18];
            } // if(nv.bootcount == 0)
        } else // if (model == MB_MODEL_MPX)
        {
            server.log("Can't find  MPX ireg MODBUS registers! Model = "+model);
            MB_ADDR_MPX_Found--; // Didn't find PT-500 Modbus data
        }
    } else // if (a.len() > 0) 
    {   // no data in APG MB array
        server.log("Can't read MPX ireg MODBUS registers!");
        MB_ADDR_MPX_Found--; // Didn't find PT-500 Modbus data
    }
} // function logMB_MPX_ireg() 

// ICHEM Modbus Handler - Holding Registers
function logMB_ICHEM() 
{
    // If MB communication not working, quit trying after 
    // MB_timesfound tries
    if (MB_ADDR_ICHEM_Found < MB_timesfound) return; 

    // The a stands for all bytes but I didn't want to type it out so many times.
    local a = [ ];
    a = MBreadHoldingRegisters(MB_ADDR_ICHEM, 0, 40);
    
    // Some of these are supposed to be unsigned.  Are those being read correctly?
    if (a.len() > 8) 
    {   
        MB_ADDR_ICHEM_Found++; // Found ICHEM Modbus Data
        
        const ICHEM_HREG = "iChem_hreg";
        agent.send(ICHEM_HREG, a); // Send raw data to Agent
        
        // MB Data available in the array
        server.log("-- ICHEM data array length: "+a.len());
//        server.log(format("== APG Dev addr: %d; Units: %d; App type: %d; a[3]: %d", a[0], a[1], a[2], a[3]));   
//        foreach (key, val in a)
//        {
//            server.log("device ICHEM key: "+key+" val: "+val)
//        }
/*
const ICHEM_MONTH = "ICHEM_month";
const ICHEM_DAY = "ICHEM_day";
const ICHEM_YEAR = "ICHEM_year";
const ICHEM_HOUR = "ICHEM_hour";
const ICHEM_MIN = "ICHEM_min";
const ICHEM_SEC = "ICHEM_sec";
*/
        nv.sensor[ICHEM_MONTH] <- -2;
        nv.sensor[ICHEM_DAY] <- -2;
        nv.sensor[ICHEM_YEAR] <- -2;
        nv.sensor[ICHEM_HOUR] <- -2;
        nv.sensor[ICHEM_MIN] <- -2;
        nv.sensor[ICHEM_SEC] <- -2;
        
    } else 
    {   // no data in APG MB array
        server.log("Can't read ICHEM MODBUS registers!");
        MB_ADDR_ICHEM_Found--; // Didn't find ICHEM Modbus Data
    }
} // function logMB_ICHEM() 

// Try to locate Modbus devices by cycling through addresses
// and looking for a response
function findMB() 
{
//    local d = date(); 

    // The a stands for all bytes but I didn't want to type it out so many times.
    local a = [ ];
    local addr;
    for(local addr = 0; addr < 25; addr++ )
    {
        a = MBreadHoldingRegisters(addr, 0, 20);
    
    // Some of these are supposed to be unsigned.  Are those being read correctly?
    if (a.len() > 8) 
    {   // MB Data available in the array
        server.log("-- MB data array length: "+a.len());
//        server.log(format("== APG Dev addr: %d; Units: %d; App type: %d; a[3]: %d", a[0], a[1], a[2], a[3]));   
        foreach (key, val in a)
        {
            server.log("MB key: "+key+" val: "+val)
        }
        findMBaddr = 0; // found MB info
        server.log("Found MB info on addr: "+addr);
    } else 
    {   // no data in APG MB array
        server.log("Can't read MODBUS address: "+addr);
    }
    } // end for loop
} // function findMB()

//*************************************************

// Send data to the agent
function transmitData() 
{
    // send gathered data
    nv.sensor[BOOTCOUNT] <- nv.bootcount++;
    nv.sensor[TIME] <- t;
    agent.send(TABLEDATA, nv.sensor);
//    nv.sensor = {};
    nv.sensor.clear();
        // rssi must be sampled while the WiFi is turned on
        // most of the time the WiFi is off, except here, where data has 
        // just been transmitted.
    nv.sensor[RSSI] <- imp.rssi();
    nv.sensor[MEMORY] <- imp.getmemoryfree();
    nv.sensor[LIGHTLEVEL] <- hardware.lightlevel();
    nv.sensor[WAKEREASON] <- hardware.wakereason();
}   // function transmitData() 

// log data in between transmit times
function logdata() 
{
//  local min = (t/60) % 60;
  local sec = t % 60;
  
  HW_RegulatorCntl.write(REGULATOR_ON); // turn on regulator
  imp.sleep(REGULATOR_DELAY); // Wait for regulator voltage to come up
        // While waiting for regulator, read switches
    nv.sensor[SWITCH1] <- HW_Switch1.read();
    nv.sensor[SWITCH2] <- HW_Switch2.read();
    // also read battery voltage on pin 9
    local adval = HW_BatV.read(); // 0 - 65535
    
    local volts = (hardware.voltage()/4096.0) * (adval/16.0); 
    // R1 = 357k and R2 = 96.7k (actual measurements)
    // Vbat = V (R1 + R2)/R2    // from the voltage divider
    // need to measure resistors for accuracy
    //   local vbat = volts * (323.6 + 1001.1.0)/100.0;
    // measured ratio of 4.59
    local vbat = volts * 4.59;
    nv.sensor[VBAT] <- vbat;
    // Get sensor voltage
  local Analog1Volts = (hardware.voltage()/4096.0) * (HW_Analog1In.read()/16.0); // calc pressure here 
    nv.sensor[t] <- Analog1Volts;

        // Implelent hysteresis algorithm
        // Check for first time over the threshold   
  if (Analog1Volts > nv.Analog1Volts_hi && nv.Analog1Volts_switch == 0)
  {
      XmitNow = 1; // force an immediate xmit
      nv.Analog1Volts_switch = 1; // indicate over the threshold
      server.log("--! Force xmit logdata");
  }
  
  if (Analog1Volts < nv.Analog1Volts_lo && nv.Analog1Volts_switch == 1)
  {
      nv.Analog1Volts_switch = 0; // indicate under the threshold
  }
  
    // Get temperature data from pin 8
    local analogval = HW_Temp.read(); // 0 - 65535 
    
    local tempC = ((analogval * 0.00005035)-0.5)*100.0;                                                                                                           
    local tempF = (9.0/5.0)*tempC + 32.0;
    nv.sensor[TEMP] <- tempF;
    
    // get analog data from IMP002 channel
    Analog1Volts = (hardware.voltage()/4096.0) * (HW_AnalogIn002.read()/16.0); // calc pressure here 
    nv.sensor[ANALOG002] <- Analog1Volts;
    
  HW_RegulatorCntl.write(REGULATOR_OFF); // turn off regulator
}   // function logdata() 

// log pressure sensor data only
// used when in Modbus mode
function logpressure() 
{
  local sec = t % 60;
  
  HW_RegulatorCntl.write(REGULATOR_ON); // turn on regulator
  imp.sleep(REGULATOR_DELAY); // Wait for regulator voltage to come up
    // Get sensor voltage
  local Analog1Volts = (hardware.voltage()/4096.0) * (HW_Analog1In.read()/16.0); // calc pressure here 
  nv.sensor[t] <- Analog1Volts;
  
        // Implement hysteresis algorithm
        // Check for first time over the threshold   
  if (Analog1Volts > nv.Analog1Volts_hi && nv.Analog1Volts_switch == 0)
  {
      XmitNow = 1; // force an immediate xmit
      nv.Analog1Volts_switch = 1; // indicate over the threshold
      server.log("--! Force xmit logpressure");
  }
  
  if (Analog1Volts < nv.Analog1Volts_lo && nv.Analog1Volts_switch == 1)
  {
      nv.Analog1Volts_switch = 0; // indicate under the threshold
  }
  
  // Get temperature data from pin 8
    local analogval = HW_Temp002.read(); // 0 - 65535 
    
    local tempC = ((analogval * 0.00005035)-0.5)*100.0;                                                                                                           
    local tempF = (9.0/5.0)*tempC + 32.0;
    nv.sensor[TEMP002] <- tempF;
    
    // get analog data from IMP002 channel
    Analog1Volts = (hardware.voltage()/4096.0) * (HW_AnalogIn002.read()/16.0); // calc pressure here 
    nv.sensor[ANALOG002] <- Analog1Volts;
}   // function logpressure() 

// callback for Hall switch 1 flowcount
function hall1()
{
    server.log("-Hall 1 changed state");
    HW_UART002.write("Hall1");
}   // function hall1()

// callback for Hall switch 2 - IMP002
function hall2()
{
    server.log("-Hall 2 changed state");
}   // function hall2()

// called when bytes are received on RS-232
// Function triggered by receipt of a byte from the connected computer
// Adds the input byte as an alphanumeric character to a buffer string
// which is displayed in the log when the remote user hits Enter
input_string <- ""; // initialize string
function readback()
{
    local byte = HW_UART002.read();
        // ignore initial input
    if (byte == -1) return;
    if (byte == 13)
    {   // handle receipt of CR
        // Output string and reset input_string for next set of chars
        server.log("Sent string: "+input_string);
        input_string = ""; // reset string
    } else
    {
        // add input character to input_string buffer
        input_string = input_string + chr(byte);
    }
}   // function readback()
// receive individual characters from RS-232
function chr(ascii_value)
{
    // convert passed integer value ASCII code
    // into a character string
    if (ascii_value < 32) return "";
    return format("%c", ascii_value);
} // function chr(ascii_value)

// Hardware set-up
// Hardware seems to need reinitialized when coming out of deep sleep
function hardwareSetUp()
{
/* redundant
    if(nv.PUMP == NOT_CONFIGURED)
    {
        server.log("-Device hardware not configured!");
        return;
    }
*/
    // IMP002 I/O pins - Available in both modes
    HW_Temp002.configure(ANALOG_IN); // temperature sensor
    HW_AnalogIn002.configure(ANALOG_IN); // second analog channel
            // UART connection to RS-232 channel
            // Pin 6 and Pin E are used for Write & Read
            // readback function called for incoming bytes
    HW_UART002.configure(9600, 8, PARITY_NONE, 1, NO_CTSRTS, readback);
     
    // Analog on pin7 is avail in both modes
    HW_Analog1In.configure(ANALOG_IN);
    // Digital Write on pin 5 - control 3V regulator for sensors                                                                                                      
    HW_RegulatorCntl.configure(DIGITAL_OUT);
    
//  PUMP_MODE = 1;
//  TRANSDUCER_MODE = 0; 
    if(nv.PUMP == PUMP_MODE)
    {
        HW_RegulatorCntl.write(REGULATOR_ON); // turn on regulator
            // UART connection to RS-485 channel
            // Pin 8 and Pin 9 are used for Write & Read
            // Pins 1 & 2 are not used for uart and are reassigned below
        HW_MBUart1.configure(9600, 8, PARITY_NONE, 1, NO_CTSRTS);
            // Pin 1 is Hall switch pulse input
        HW_FlowCount.configure(DIGITAL_IN_PULLUP, hall1); // flow meter count
        HW_Hall002.configure(DIGITAL_IN_PULLUP, hall2); // second hall switch
            // Pin 2 control direction of RS-485 Read or Write
        HW_ModBusDir.configure(DIGITAL_OUT);
        // Digital Write on pin 5 - control 3V regulator for sensors                                                                                                      
//        HW_RegulatorCntl.configure(DIGITAL_OUT);
            // Pressure Sensor input
    } else
    {   // Transducer Mode
//        server.log("Transducer Mode - Hardware Analog Input");
        // switch1 
        HW_Switch1.configure(DIGITAL_IN);
        // switch2
        HW_Switch2.configure(DIGITAL_IN);
        // Digital Write on pin 5 - control 3V regulator for sensors                                                                                                      
//        HW_RegulatorCntl.configure(DIGITAL_OUT);
        // Analog read on pin 8 for temp                                                                                                                                  
        HW_Temp.configure(ANALOG_IN);
        // Analog read on pin 9 for scaled battery voltage                                                                                                                             
        HW_BatV.configure(ANALOG_IN); 
    }
}   // function hardwareSetUp()

// dispatch logdata() and transmitdata() if time for xmit
function dispatch()
{
//    wakeReason(); // How did Imp wake up?
    // When the Imp comes out of deep sleep, it starts here
    // log an ADC value each 10 sec, only tell the server each minute 
    t = time();
    if(nv.PUMP == NOT_CONFIGURED)
    {
        server.log("--Waiting for configuration--");
//        return;
        
//        imp.onidle(function()
//        {
//            server.log("--Waiting for configuration--");
//            server.log("-Device not configured!");
        imp.wakeup(2.0, dispatch);
            
//            imp.sleep(5.0);
//            server.log("--after sleep");
//            dispatch();
//        });
//        server.log("--after onidle");
        return;
    }
    imp.onidle(null);
        // Now we can set-up hardware with nv.PUMP defined
    hardwareSetUp();
//  PUMP_MODE = 1;
//  TRANSDUCER_MODE = 0;     
    if(nv.PUMP == PUMP_MODE)
    {
        // Do this once
        if(findMBaddr == 1)
        {
          findMB();  
        }

// MB_ADDR_TimeMark <- 0x10;
// MB_ADDR_PT500 <- 0x01;
// MB_ADDR_MPX <- 0x01;
// MB_ADDR_ICHEM <- 0x01;

 // MB_ADDR_TimeMark_Found <- 0;
 // MB_ADDR_PT500_Found <- 0;
 // MB_ADDR_MPX_Found <- 0;
 // MB_ADDR_ICHEM_Found <- 0;
 
        server.log(format("** TimeMark: %d; PT-500: %d; MPX: %d; ICHEM: %d", 
                      MB_ADDR_TimeMark_Found, MB_ADDR_PT500_Found
                      MB_ADDR_MPX_Found, MB_ADDR_ICHEM_Found))
 
        // Give the Modbus test several tries before
        // shutting it off
 //       if (MB_ADDR_TimeMark_Found >= -5)
 //       {
            logMB_TimeMark(); // sample MB registers
//        }
//        logMB_APG();
        imp.sleep( 0.5 );
        
//        if (MB_ADDR_PT500_Found >= -5)
//        {
            logMB_APG_ireg();
//        }
        imp.sleep( 0.5 );
        
//        if(MB_ADDR_MPX_Found >= -5)
//        {
            logMB_MPX_ireg();
//        }
//        logMB_ICHEM();
 //       if(MB_ADDR_ICHEM_Found >= -5)
//        {
            logMB_ICHEM();
//        }

        logpressure(); 
    } else if (nv.PUMP == TRANSDUCER_MODE)
    {
        logdata();  // sample analog data first
    } else
    {
        server.log("---*** PUMP mode not set");
    }
        // check to see if time to xmit
    if (t >= (nv.time + nv.XMIT_PERIOD) || XmitNow)
    {
        XmitNow = 0; // set back to false
        // increment bootcount with each xmit
//        nv.sensor[BOOTCOUNT] <- nv.bootcount++;
        // send xmit time data
        nv.time = t; // save xmit time
            // get Imp rssi and memory info
            // only send at startup
            // tell agent when to expect next transmission
        server.expectonlinein(nv.XMIT_PERIOD);
        transmitData(); // transmit the data to agent
    }

        // Sync to the sample period - sleep for one sample period
    if(nv.PUMP == PUMP_MODE)
    {
        imp.onidle(function()
        {imp.wakeup(nv.SAMPLE_PERIOD - (time() % nv.SAMPLE_PERIOD), dispatch )
        });
    } else
    {
        imp.onidle(function() { 
		// Make sure the regulators turn off before going to deep sleep
		HW_RegulatorCntl.write( REGULATOR_OFF );

		// Configure pin1 for wakeup
		HW_Wakeup.configure( DIGITAL_IN_WAKEUP, function(){ } );

		// Go to sleep
		imp.deepsleepfor(nv.SAMPLE_PERIOD - (time() % nv.SAMPLE_PERIOD)); 
	});
    }
}   // function dispatch()

// if just turned on, and nv doesn't exist
if (!("nv" in getroottable())) 
{
    server.log("++++++++++ Start 1st Pass ++++++++++");
    
    imp.enableblinkup(true);                                                                                                                                          
    
    local endtime = hardware.millis() + 10 * 1000; // set the end time by adding msecs                                                                                
    while((endtime - hardware.millis()) > 0) 
    {                                                                                                      
        if (hardware.millis()%1000 == 0) 
        {                                                                                                                            
            server.log("Blink up anyone?");                                                                                                                           
        }                                                                                                                                                             
        if ((endtime - hardware.millis()) < 0) 
        { // time expired?                                                                                                     
            break;                                                                                                                                                    
        }                                                                                                                                                             
    } 
    
    nv <- {     // data = "",  // data string accumulates data with each sample period
            sensor = {}, // table for sensor data
            MB = {},    // table for MB register
            meta = {},  // meta data about this device
            time = t,  // time stores the time at beginning of each transmission
            bootcount = 0, // bootcount is incremented on each wakeup
            
                // default settings
            PUMP = NOT_CONFIGURED, // Pump controller Module?
            XMIT_PERIOD = 10, // Time between transmissions
            SAMPLE_PERIOD = 10, // Time between samples
            TIMER_HANDLE = 0,
            
            // Set up trigger points
            // The trigger threshold has an upper and lower value
            // based on the range in order to implement hysteresis
            IMP_ANALOG1_THRESHOLD = -1,
            IMP_ANALOG1_RANGE = 0.1,
            
            
            // Check for hi and lo conditions using hysteresis algorithm
            // Analog channel 1
            Analog1Volts_hi = 1.1, // High voltage
            Analog1Volts_lo = 1.0, // Low voltage
                // Switch tells us if above the trigger or below
            Analog1Volts_switch = 0, // switch starts at off
        };
        // send Imp information to agent
        nv.meta[SSID] <- imp.getssid();
        nv.meta[DEVID] <- hardware.getdeviceid();
        nv.meta[IMPTYPE] <- "IMP001";
            if ("pinA" in hardware)
        {
//            server.log("--Running IMP002 module");
            nv.meta[IMPTYPE] <- "IMP002";
        }
        agent.send(METADATA, nv.meta);
}

    // dispatch logs data and then decides if
    // it is time to send data package to agent
dispatch(); // log and transmit
// server.log("---DEVICE CODE END---");

