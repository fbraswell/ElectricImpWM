// Agent code for Data Test
server.log("---AGENT START---");
const XIVELY_URL = "https://api.xively.com/v2/feeds/";  // Xively base URL
const XIVELY_Account_Authorization = "Basic a25pZ2h0aGF3azprbmlnM3QzOHdr"; // WellMark knighthawk auth
const PUMP_MODE = 1;
const TRANSDUCER_MODE = 0; 

// myDevID <- "no Imp dev id yet";
IMP_DEV_ID <- "no Imp dev id yet";
XIVELY_FEED <- 0;   // Xively feed # will go here
XIVELY_FEED_NAME <- "xively feed name"; // Xively Feed Name
XIVELY_API_ENDPOINT <- "no Xively endpoint yet";
// agent_myapikey <- "no Xively feed key yet";
XIVELY_API_KEY <- "no Xively feed key yet";

MB_Device_Data <- { };

// Collection of selected data to be sent to Xively
// every time - The entire set of variables is only
// sent when bootcount == 0, at start-up or restart

MB_Each_time <-
{
    MB_Cycles = -2,
    MB_QuartsPerDay = -2,
    MB_Temperature = -2,
                             
    PT500_pressure_h2o = -2,
    PT500_tempC = -2,
                             
    MPX_topdistin = -2,
    MPX_botdistin = -2,
    MPX_tempC = -2,
    
    TM_onsec = -2,
    TM_onmin = -2,
    TM_onhr = -2,
    TM_offsec = -2,
    TM_offmin = -2,
    TM_offhr = -2,
    TM_pumpmode = -2,
    TM_tempsetpoint = -2,
    TM_auxmode = -2,
    TM_auxonsec = -2,
    TM_auxonmin = -2,
    TM_auxonhr = -2,
    TM_auxoffsec = -2,
    TM_auxoffmin = -2,
    TM_auxoffhr = -2,
    TM_qtperday = -2,
    TM_cyclespumpmode = -2,
    TM_currenttemp = -2,
    
    ICHEM_month = -2, // 40002 int
    ICHEM_day = -2, // 40003 int
    ICHEM_year = -2, // 40004 int
    ICHEM_hour = -2, // 40005 int
    ICHEM_min = -2, // 40006 int
    ICHEM_sec = -2, // 40007 int
    
    ICHEM_last_flow_meter_cal_month = -2, // 40008 int
    ICHEM_last_flow_meter_cal_day = -2, // 40009 int
    ICHEM_last_flow_meter_cal_year = -2, // 40010 int
    
    ICHEM_MB_cycles_freq_bitmap = -2, // 40014 int
    
    ICHEM_daily_volume = -2, // 40100 float rw
    ICHEM_daily_cycles = -2, // 40102 float
    ICHEM_injection_rate = -2, // 40104 float
    
//    ICHEMcoil_Low_Flow_Alarm_Disabled // coil
} // MB_Each_time

TimeMark_140127 <- 
{
    // Time Mark Jan 27, 2014 release
    MB_OnTime = -1,
    MB_OffTime = -1,
    MB_TempSetPoint = -1,
    MB_QuartsPerDay = -1,
    MB_Cycles = -1,
    MB_Temperature = -1,
    MB_PlungerSize = -1,
    MB_PinPosition = -1,
    MB_MotorSize = -1,
    MB_BatteryVoltage = -1,
    MB_VersionNumber = -1,
    
    // coils
    MB_Auto_Manual_Mode = -1, // coil addr1
    MB_Timer_Mode = -1, // coil addr2
    MB_Temp_Mode = -1, // coil addr3
    MB_Comm_Mode = -1, // coil addr4
} // TimeMark_140127

TimeMark <-
{
    // Time Mark Fall 2014 release
    TM_onsec = -1,
    TM_onmin = -1,
    TM_onhr = -1,
    TM_offsec = -1,
    TM_offmin = -1,
    TM_offhr = -1,
    TM_pumpmode = -1,
    TM_tempsetpoint = -1,
    TM_auxmode = -1,
    TM_auxonsec = -1,
    TM_auxonmin = -1,
    TM_auxonhr = -1,
    TM_auxoffsec = -1,
    TM_auxoffmin = -1,
    TM_auxoffhr = -1,
    TM_qtperday = -1,
    TM_cyclespumpmode = -1,
    TM_currenttemp = -1,
    TM_plungersize = -1,
    TM_pinpos = -1,
    TM_motorsize = -1,
    TM_gearratio = -1,
    TM_tahpulse = -1,
    TM_voltage = -1,
    TM_version = -1,
    TM_pwm = -1,
    TM_motortachT3 = -1,
    TM_avgT3 = -1,
    TM_calctach = -1,
    TM_RTChr = -1,
    TM_RTCminsec = -1,
    TM_RTCmo = -1,
    TM_RTCdayyr = -1,
    TM_ana1 = -1,
    TM_ana2 = -1,
    
        // coils
    TM_Timer_Mode = -1, // coil addr0
	TM_Temp_Mode = -1, // coil addr1
	TM_Off_First = -1, // 1 = off first addr2
	TM_Variable_Speed_Mode = -1, // variable speed addr3
	TM_Auto_Manual_Mode = -1, // Auto coil addr4
	TM_Aux_Mode = -1, // Aux enable addr5
	TM_Reserved = -1, // unused addr6
	TM_Comm_Mode = -1, // Comm enable coil addr7
} // TimeMark

PT500 <- 
{
    PT500_model = -1,
    PT500_pressure_h2o = -1,
    PT500_tempC = -1,
    PT500_calc = -1,
    PT500_batv = -1
} // PT500

MPX <-
{
    MPX_model = -1,
    MPX_topdist = -1,
    MPX_topdistin = -1,
    MPX_botdist = -1,
    MPX_botdistin = -1,
    MPX_tempC = -1,
    MPX_topcalc = -1,
    MPX_botcalc = -1
} // MPX

ICHEM <-
{
        // integer registers start at 0
        // all the ints are read only - RO
    ICHEM_month = -1, // 40002 int - RO
    ICHEM_day = -1, // 40003 int - RO
    ICHEM_year = -1, // 40004 int - RO
    ICHEM_hour = -1, // 40005 int - RO
    ICHEM_min = -1, // 40006 int - RO
    ICHEM_sec = -1, // 40007 int - RO
    
    ICHEM_last_flow_meter_cal_month = -1, // 40008 int - RO
    ICHEM_last_flow_meter_cal_day = -1, // 40009 int - RO
    ICHEM_last_flow_meter_cal_year = -1, // 40010 int - RO
    
    ICHEM_MB_cycles_freq_bitmap = -1, // 40014 int - RO
    
    ICHEM_last_cycle_freq_change_year = -1, // 40015 int - RO
    ICHEM_last_cycle_freq_change_month = -1, // 40016 int - RO
    ICHEM_last_cycle_freq_change_day = -1, // 40017 int - RO

    ICHEM_last_flow_meter_check_year = -1, // 40018 int - RO
    ICHEM_last_flow_meter_check_month = -1, // 40019 int - RO
    ICHEM_last_flow_meter_check_day = -1, // 40020 int - RO
    
    ICHEM_last_volume_change_year = -1, // 40021 int - RO
    ICHEM_last_volume_change_month = -1, // 40022 int - RO
    ICHEM_last_volume_change_day = -1, // 40023 int - RO
    
    ICHEM_completed_daily_cycles = -1, // 40024 int - RO
    ICHEM_pumped_daily_cycles = -1, // 40025 int - RO
    
    ICHEM_manual_mode_entry_year = -1, // 40026 int - RO
    ICHEM_manual_mode_entry_month = -1, // 40027 int - RO
    ICHEM_manual_mode_entry_day = -1, // 40028 int - RO
    
    ICHEM_last_custom_batch_year = -1, // 40029 int - RO
    ICHEM_last_custom_batch_month = -1, // 40030 int - RO
    ICHEM_last_custom_batch_day = -1, // 40031 int - RO
    
    ICHEM_ext_sys_override_year = -1, // 40032 int - RO
    ICHEM_ext_sys_override_month = -1, // 40033 int - RO
    ICHEM_ext_sys_override_day = -1, // 40034 int - RO
    
    ICHEM_sys_fail_year = -1, // 40035 int - RO
    ICHEM_sys_fail_month = -1, // 40036 int - RO
    ICHEM_sys_fail_day = -1, // 40037 int - RO
    
    ICHEM_battery_alert_year = -1, // 40038 int - RO
    ICHEM_battery_alert_month = -1, // 40039 int - RO
    ICHEM_battery_alert_day = -1, // 40040 int - RO
    ICHEM_battery_alert_hour = -1, // 40041 int - RO
    ICHEM_battery_alert_min = -1, // 40042 int - RO
    
    ICHEM_battery_alarm_year = -1, // 40043 int - RO
    ICHEM_battery_alarm_month = -1, // 40044 int - RO
    ICHEM_battery_alarm_day = -1, // 40045 int - RO
    ICHEM_battery_alarm_hour = -1, // 40046 int - RO
    ICHEM_battery_alarm_min = -1, // 40047 int - RO
    
    ICHEM_low_tank_year = -1, // 40048 int - RO
    ICHEM_low_tank_month = -1, // 40049 int - RO
    ICHEM_low_tank_day = -1, // 40050 int - RO
    
    ICHEM_hi_flow_year = -1, // 40051 int - RO
    ICHEM_hi_flow_month = -1, // 40052 int - RO
    ICHEM_hi_flow_day = -1, // 40053 int - RO
    
    ICHEM_low_flow_year = -1, // 40054 int - RO
    ICHEM_low_flow_month = -1, // 40055 int - RO
    ICHEM_low_flow_day = -1, // 40056 int - RO
    ICHEM_low_flow_hour = -1, // 40057 int - RO
    ICHEM_low_flow_min = -1, // 40058 int - RO
    
    ICHEM_pump_type = -1, // 40059 int - RO
    
    ICHEM_time_based_pump_cycles = -1, // 40060 int - RO
    
    
        // Floats start at 100    
    ICHEM_daily_volume = -1, // 40100 float - RW
    ICHEM_daily_cycles = -1, // 40102 float - RO
    ICHEM_injection_rate = -1, // 40104 float - RO
    ICHEM_accum_cycle_vol = -1, // 40106 float - RO
    ICHEM_accum_daily_vol = -1, // 40108 float - RO
    ICHEM_curr_tank_lev = -1, // 40110 float - RO
    ICHEM_fm_k_factor = -1, // 40112 float - RO
    ICHEM_yesterday_volume = -1, // 40114 float - RO
    ICHEM_week_volume = -1, // 40116 float - RO
    ICHEM_month_volume = -1, // 40118 float - RO
    ICHEM_year_volume = -1, // 40120 float - RO
    ICHEM_forever_volume = -1, // 40122 float - RO
    
    ICHEM_custom_batch_volume = -1, // 40124 float - RW
    ICHEM_remaining_batch_volume = -1, // 40126 float - RO
    ICHEM_cycle_countdown = -1, // 40128 float - RO
    ICHEM_cycle_duration = -1, // 40130 float - RO
    ICHEM_calc_cycle_difference = -1, // 40132 float - RO
    ICHEM_adj_target_cycle_volume = -1, // 40134 float - RO
    ICHEM_target_cycle_volume = -1, // 40136 float - RO
    ICHEM_current_battery_volts = -1, // 40138 float - RO
    ICHEM_batch_catch_volume = -1, // 40140 float - RO
    ICHEM_dynamic_unit_ratio = -1, // 40142 float - RW
    ICHEM_dynamic_chem_ratio = -1, // 40144 float - RW
    ICHEM_dynamic_calc_ratio = -1, // 40146 float - RO
    ICHEM_dynamic_rate = -1, // 40148 float - RW
    ICHEM_dynamic_max_injection_volume = -1, // 40150 float - RW
    ICHEM_dynamic_min_injection_volume = -1, // 40152 float - RW
    ICHEM_est_max_pump_output = -1, // 40154 float - RO
    ICHEM_production_unit_ext_override_hi_setpoint = -1, // 40156 float - RW
    ICHEM_production_unit_ext_override_lo_setpoint = -1, // 40158 float - RW
    
        // ICHEM coils
 	ICHEMcoil_Manual_Mode = -1,	// coil 10000 - RW
	ICHEMcoil_Start_Pump = -1,	// coil 10001 - RW
	ICHEMcoil_Pump_Status = -1,	// coil 10002 - RO
	ICHEMcoil_Low_Flow_Alarm_Disabled = -1,	// coil 10003 - RW
	ICHEMcoil_Low_Flow_Alarm_Active = -1,	// coil 10004 - RO
	ICHEMcoil_Low_Flow_Alarm_Reset = -1,	// coil 10005 - momentary WO
	ICHEMcoil_Reset_Yesterday_Vol = -1,	// coil 10006 - momentary WO
	ICHEMcoil_Reset_Week_Vol = -1,	// coil 10007 - momentary WO
	ICHEMcoil_Reset_Month_Vol = -1,	// coil 10008 - momentary WO
	ICHEMcoil_Reset_Year_Vol = -1,	// coil 10009 - momentary WO
	ICHEMcoil_Reset_Forever_Vol = -1,	// coil 10010 - momentary WO
	ICHEMcoil_Reserved = -1,	// coil 10011
	ICHEMcoil_Set_1_Min_Cycle_Freq = -1,	// coil 10012 - momentary WO
	ICHEMcoil_Set_15_Min_Cycle_Freq = -1,	// coil 10013 - momentary WO
	ICHEMcoil_Set_30_Min_Cycle_Freq = -1,	// coil 10014 - momentary WO
	ICHEMcoil_Set_1_Hour_Cycle_Freq = -1,	// coil 10015 - momentary WO
	ICHEMcoil_Set_6_Hr_Cycle_Freq = -1,	// coil 10016 - momentary WO
	ICHEMcoil_Set_12_Hr_Cycle_Freq = -1,	// coil 10017 - momentary WO
	ICHEMcoil_Set_Daily_Cycle_Freq = -1,	// coil 10018 - momentary WO
	ICHEMcoil_Start_Custom_Batch = -1,	// coil 10019 - momentary WO
	ICHEMcoil_Stop_Custom_Batch = -1,	// coil 10020 - momentary WO
	ICHEMcoil_Low_Tank_Alert = -1,	// coil 10021 - RO
	ICHEMcoil_Low_Battery_Alert = -1,	// coil 10022 - RO
	ICHEMcoil_Low_Battery_Alarm = -1,	// coil 10023 - RO
	ICHEMcoil_Low_Battery_Alarm_Reset = -1,	// coil 10024 - RO
	ICHEMcoil_Digital_Output_Interface_Enabled = -1,	// coil 10025 - RW
	ICHEMcoil_External_Override_Enabled = -1,	// coil 10026 - RW
	ICHEMcoil_External_Override_Active = -1,	// coil 10027 - RO
	ICHEMcoil_Hi_Flow_Alarm_Active = -1,	// coil 10028 - RO
	ICHEMcoil_Start_Batch_Catch = -1,	// coil 10029 - momentary WO
	ICHEMcoil_Dynamic_Flow_Enabled = -1,	// coil 10030 - RW
	ICHEMcoil_Dynamic_Max_Flow_Enabled = -1,	// coil 10031 - RW
	ICHEMcoil_Dynamic_Min_Flow_Enabled = -1,	// coil 10032 - RW
	ICHEMcoil_Production_Unit_External_Override_HI_Enalbed = -1,	// coil 10033 - RW
	ICHEMcoil_Production_Unit_External_Override_LO_Enalbed = -1,	// coil 10034 - RW
	ICHEMcoil_Production_Unit_External_Override_HI_Status = -1,	// coil 10035 - RO
	ICHEMcoil_Production_Unit_External_Override_LO_Status = -1,	// coil 10036 - RO
	ICHEMcoil_Recovery_with_Time_on_Low_Flow_Alarm_Enabled = -1,	// coil 10037 - RW
	ICHEMcoil_Recovery_with_Time_on_Low_Flow_Alarm_Status = -1,	// coil 10038 - RO 
    
} // ICHEM

// Defaults
IMP_SAMPLE_PER <- 10; // Default 10 sec sample period
IMP_XMIT_PER <- 60; // Default 60 sec transmit period
// IMP_MODE <- TRANSDUCER_MODE; // Mode 0 = transducer only; Mode 1 = Pump
IMP_MODE <- PUMP_MODE; // Mode 0 = transducer only; Mode 1 = Pump

// Default trigger points
// If a trigger is exceeded, the Imp reports the event immediately
// Immediate means the Imp reports on the next sample period, not waiting for
// the scheduled xmit time.
// More data channels will be added as needed
IMP_ANALOG1_THRESHOLD <- -1; // trigger threshold
IMP_ANALOG1_RANGE <- 0.1; // hysteresis range - 1/2 above, 1/2 below threshsold

// IMP_DEV_ID  = strip(xivelyInfo[0]);
const X_IMP_DEV_ID = 0;
const X_XIVELY_FEED_NAME = 1;
const X_XIVELY_FEED = 2;
const X_XIVELY_API_KEY = 3;
const X_IMP_SAMPLE_PER = 4;
const X_IMP_XMIT_PER = 5;
const X_IMP_MODE = 6;
const X_IMP_ANALOG1_THRESHOLD = 7;
const X_IMP_ANALOG1_RANGE = 8;

// Imp Wake Codes

impWakeCodes <-
[
//    Code    Description
     "The power was turned on", // 0
     "A software reset took place", // 1
     "An event timer fired", // 2
    "Pulse detected on Wakeup Pin", // 3
    "New Squirrel code downloaded", // 4
    "Squirrel runtime error", // 5
    "impOS update", // 6
    "A snooze-and-retry event", // 7
        // imp003 only
    "Hardware reset", // 8
];

// extracct 16 bit int register from 
// modbus array
function MB_toint16(register, offset, a)
{
  // the first three locations of the modbus
  // array are used for comm data
  // a[0] = MB address
  // a[1] = MB command
  // a[2] = MB length of data
  // The registers start at location 3
  // The register at loc 3 may be offset from 0
  // in the block of data
    // The array is made up of pairs, representing
    // 8 bit values from the MB read
    // Shift the first upper byte value by 8 and OR it with
    // the adjacent lower byte to get the
    // 16 bit int
    // two regs per word offset by 3 locations
    // and back by 2 because index origin is 1, not 0
    local aloc = ((register - offset) * 2) + 3 - 2; 
    if(aloc+1 > (a.len() - 1))
    {
        return null;
    }
  return (a[aloc] << 8) | a[aloc + 1];
} // function MB_toint16(register, offset, a)

function MB_toint32(register, offset, a)
{
    // MB_toint32 is similar to MB_toint16, except
    // we put together 4 registers
    local aloc = ((register - offset) * 2) + 3 - 2; 
    if(aloc+3 > (a.len() - 1))
    {
        return null;
    }
    return (a[aloc] << 24) | (a[aloc + 1] << 16) 
            | (a[aloc + 2] << 8) | a[aloc + 3];
} // function MB_toint32(register, offset, a)

function MB_tofloat32(register, offset, a)
{
    // MB_tofloat32 is similar to MB_toint32, except
    // we put together 4 registers and cast to float
    local aloc = ((register - offset) * 2) + 3 - 2;
    if (aloc+3 > (a.len() - 1))
    {
        return null;
    }
    return casti2f((a[aloc] << 24) | (a[aloc + 1] << 16) 
            | (a[aloc + 2] << 8) | a[aloc + 3]);
//    return casti2f((a[aloc+2] << 24) | (a[aloc + 3] << 16) 
//            | (a[aloc + 0] << 8) | a[aloc + 1]);
} // function MB_tofloat32(register, offset, a)

function MB_coiltobit(coil, offset, a)
{
    
}

function MB_error_check(a)
{
    // a[0] is physical addr byte
    // a[1] is command byte
    // a[2], a[3] is length of data
    if (a[1] == 0)
    {
        // invalid command code
        server.log(format("-&& MB Error! - PhyAddr: %d, MBcode: %d, LengthData: %d:%d", a[0], a[1], a[2], a[3]));
        return 0;
    } else if(a[1] > 128)
    {
        // command returned error
        server.log(format("-&& MB Error! - PhyAddr: %d, MBcode: %d, LengthData: %d:%d", a[0], a[1], a[2], a[3]));
        return 0;
    }
    return 1; // good MB package
}

const TIME_MARK_JAN14 = "time_mark_jan14";
device.on(TIME_MARK_JAN14, function(a)
{
//    foreach (key, val in data)
//        {
//            server.log("Time Mark key: "+key+" val: "+val)
//        }
    if(MB_error_check(a) == 0)
    {
        return; // Found MB data error
    }
    // version number for Jan 14, 2014 = 140127
    TimeMark_140127.MB_VersionNumber <- MB_toint32(14, 0, a);
    if(TimeMark_140127.MB_VersionNumber == 140127)
    {
        // This is older version
        server.log("--* Found version 140127!");
    
        TimeMark_140127.MB_OnTime <- MB_toint16(1, 0, a);
        TimeMark_140127.MB_OffTime <- MB_toint16(2, 0, a);
        TimeMark_140127.MB_TempSetPoint <- MB_toint16(3, 0, a);
        TimeMark_140127.MB_QuartsPerDay <- MB_tofloat32(4, 0, a);
        TimeMark_140127.MB_Cycles <- MB_toint32(6, 0, a);
        TimeMark_140127.MB_Temperature <- MB_toint16(8, 0, a);
        TimeMark_140127.MB_PlungerSize <- MB_toint16(9, 0, a);
        TimeMark_140127.MB_PinPosition <- MB_toint16(10, 0, a);
        TimeMark_140127.MB_MotorSize <- MB_toint16(11, 0, a);
        TimeMark_140127.MB_BatteryVoltage <- MB_tofloat32(12, 0, a);
        MB_Device_Data.TimeMark_140127 <- TimeMark_140127;
    } else
    {
            foreach (key, val in a)
        {
            server.log("Time Mark New key: "+key+" val: "+val)
        }
        
            // Time Mark Fall 2014 release
        const TMoffset = -1;
        TimeMark.TM_onsec <- MB_toint16(0, TMoffset, a);
        TimeMark.TM_onmin <- MB_toint16(1, TMoffset, a);
        TimeMark.TM_onhr <- MB_toint16(2, TMoffset, a);
        TimeMark.TM_offsec <- MB_toint16(3, TMoffset, a);
        TimeMark.TM_offmin <- MB_toint16(4, TMoffset, a);
        TimeMark.TM_offhr <- MB_toint16(5, TMoffset, a);
        TimeMark.TM_pumpmode <- MB_toint16(6, TMoffset, a);
        TimeMark.TM_tempsetpoint <- MB_toint16(7, TMoffset, a);
        TimeMark.TM_auxmod <- MB_toint16(8, TMoffset, a);
        TimeMark.TM_auxonsec  <- MB_toint16(9, TMoffset, a);
        TimeMark.TM_auxonmin <- MB_toint16(10, TMoffset, a);
        TimeMark.TM_auxonhr <- MB_toint16(11, TMoffset, a);
        TimeMark.TM_auxoffsec <- MB_toint16(12, TMoffset, a);
        TimeMark.TM_auxoffmin <- MB_toint16(13, TMoffset, a);
        TimeMark.TX_auxoffhr <- MB_toint16(14, TMoffset, a);
        
        TimeMark.TM_qtperday <- MB_tofloat32(15, TMoffset, a);
        TimeMark.TM_cyclespumpmode <- MB_toint32(17, TMoffset, a);
        
        TimeMark.TM_currenttemp <- MB_toint16(19, TMoffset, a);
        TimeMark.TM_plungersize <- MB_toint16(20, TMoffset, a);
        TimeMark.TM_pinpos <- MB_toint16(21, TMoffset, a);
        TimeMark.TM_motorsize <- MB_toint16(22, TMoffset, a);
        
        TimeMark.TM_gearratio <- MB_tofloat32(23, TMoffset, a);
        TimeMark.TM_tahpulse <- MB_toint16(25, TMoffset, a);
        
        TimeMark.TM_voltage <- MB_tofloat32(26, TMoffset, a);
        TimeMark.TM_version <- MB_toint32(28, TMoffset, a);
        
        TimeMark.TM_pwm <- MB_toint16(30, TMoffset, a);
        TimeMark.TM_motortachT3 <- MB_toint16(31, TMoffset, a);
        TimeMark.TM_avgT3 <- MB_toint16(32, TMoffset, a);
        TimeMark.TM_calctach <- MB_toint16(33, TMoffset, a);
        TimeMark.TM_RTChr <- MB_toint16(34, TMoffset, a);
        TimeMark.TM_RTCminsec <- MB_toint16(35, TMoffset, a);
        TimeMark.TM_RTCmo <- MB_toint16(36, TMoffset, a);
        TimeMark.TM_RTCdayyr <- MB_toint16(37, TMoffset, a);
        TimeMark.TM_ana1 <- MB_toint16(38, TMoffset, a);
        TimeMark.TM_ana <- MB_toint16(39, TMoffset, a);
        MB_Device_Data.TimeMark <- TimeMark;
    }
    // put the TimeMark data table in the MB_Device_Data table
    
    
} // end of function(data)
); // end device.on(TIME_MARK_JAN14, function(data)

const TIME_MARK_JAN14_coils = "time_mark_jan14_coils";
device.on(TIME_MARK_JAN14_coils, function(a)
{
/*
    foreach (key, val in a)
        {
            server.log("Time Mark Coil key: "+key+" val: "+val)
        }
*/
    if(MB_error_check(a) == 0)
    {
        return; // Found MB data error
    }
    
    server.log("-- Coils found: "+a[2]+"; Coil Value: "+a[3]);
     // Get coil bits
        // bits are in bytes in the a array
        // bits must be shifted off of each byte
    local count = a[2];
    local bits = array(8);
    for(local cnt = 0; cnt < count; cnt++)
    {
        local byte = a[3 + cnt];
        for(local i = 0; i < 8; i++)
        {
            bits[i] = (byte >> i) & 0x01;
        }
    }
        
/*        // dump bits
        foreach(key, val in bits)
        {
            server.log("-- coil bits: key: "+key+"; val: "+val);
        }
*/
        
    // version number for Jan 14, 2014 = 140127
 //   TimeMark_140127.MB_VersionNumber <- MB_toint32(14, 0, a);
//    if(TimeMark_140127.MB_VersionNumber == 140127)
    
    // use bit7 to determine if coils are from 140127 or fall 2014
    // bit7 is only 1 if fall 2014 because bit is unused for earlier
    // version and is always 0. Also, we can never read the comm mode
    // bit as 0 because that means the comm mode would be turned off
    // and couldn't be read at all.
    if(bits[7] == 0)
    {
        // This is older version
//        server.log("--* Found version 140127 coils!");

            // coils
        TimeMark_140127.MB_Auto_Manual_Mode = bits[0];	// coil 10000
	    TimeMark_140127.MB_Timer_Mode = bits[1];	// coil 10001
    	TimeMark_140127.MB_Temp_Mode = bits[2];	// coil 10002
    	TimeMark_140127.MB_Comm_Mode = bits[3];	// coil 10003
            // put the TimeMark data table in the MB_Device_Data table
        MB_Device_Data.TimeMark_140127 <- TimeMark_140127;
    } else
    {
        TimeMark.TM_Timer_Mode = bits[0]; // coil addr0
	    TimeMark.TM_Temp_Mode = bits[1]; // coil addr1
	    TimeMark.TM_Off_First = bits[2]; // 1 = off first addr2
    	TimeMark.TM_Variable_Speed_Mode = bits[3]; // variable speed addr3
	    TimeMark.TM_Auto_Manual_Mode = bits[4]; // Auto coil addr4
	    TimeMark.TM_Aux_Mode = bits[5]; // Aux enable addr5
    	TimeMark.TM_Reserved = bits[6]; // unused addr6
    	TimeMark.TM_Comm_Mode = bits[7]; // Comm enable coil addr7
            // put the TimeMark data table in the MB_Device_Data table
        MB_Device_Data.TimeMark <- TimeMark;
    }
    
} // end of function(data)
); // end device.on(TIME_MARK_JAN14_coils, function(data)

const MB_PT500_HREG = "MB_PT500_HREG";
device.on(MB_PT500_HREG, function(data)
{
    if(MB_error_check(data) == 0)
    {
        server.log("ERROR in APG PT-500 hreg data package!")
        return; // Found MB data error
    }
/*    
    foreach (key, val in data)
        {
            server.log("APG PT-500 hreg key: "+key+" val: "+val)
        }
*/
    
} // end of function(data)
); // end device.on(MB_PT500_HREG, function(data)

const MB_PT500_IREG = "MB_PT500_IREG";
device.on(MB_PT500_IREG, function(data)
{
//    foreach (key, val in data)
//        {
//            server.log("APG PT-500 ireg key: "+key+" val: "+val)
//        }
    if(MB_error_check(data) == 0)
    {
        return; // Found MB data error
    }
    // Decode registers
    PT500.PT500_model <- MB_toint16(299, 298, data);
    PT500.PT500_pressure_h2o <- MB_toint16(300, 298, data);
    PT500.PT500_tempC <- MB_toint16(302, 298, data);
    PT500.PT500_calc <- MB_toint16(304, 298, data);
    PT500.PT500_batv <- MB_toint16(308, 298, data);
//    foreach (key, val in PT500)
//    {
//        server.log("APG PT-500: "+key+": "+val);
//    }
    // put the PT500 data table in the MB_Device_Data table
    MB_Device_Data.PT500 <- PT500;
} // end of function(data)
); // end device.on(MB_PT500_IREG, function(data)

const MB_MPX_IREG = "MB_MPX_IREG";
device.on(MB_MPX_IREG, function(data)
{
//    foreach (key, val in data)
//        {
//            server.log("APG MPX ireg key: "+key+" val: "+val)
//        }
    if(MB_error_check(data) == 0)
    {
        return; // Found MB data error
    }
    // Decode registers
    MPX.MPX_model <- MB_toint16(299, 298, data);
    MPX.MPX_topdist <- MB_toint16(300, 298, data);
    MPX.MPX_topdistin <- MB_toint16(300, 298, data) / 25.4;
    MPX.MPX_botdist <- MB_toint16(301, 298, data);
    MPX.MPX_botdistin <- MB_toint16(301, 298, data) / 25.4;
    MPX.MPX_tempC <- MB_toint16(302, 298, data);
    MPX.MPX_topcalc <- MB_toint32(303, 298, data);
    MPX.MPX_botcalc <- MB_toint32(305, 298, data);
//    foreach (key, val in PT500)
//    {
//        server.log("APG MPX: "+key+": "+val);
//    }
    // put the MPX data table in the MB_Device_Data table
    MB_Device_Data.MPX <- MPX;
} // end of function(data)
); // end device.on(MB_MPX_IREG, function(data)

const ICHEM_HREG = "iChem_hreg";
device.on(ICHEM_HREG, function(data)
{
    server.log("-- agent ICHEM data array length: "+data.len());
    if(MB_error_check(data) == 0)
    {
        return; // Found MB data error
    }
    // ICHEM integer data
    const ICHEMoffset = -1;
    ICHEM.ICHEM_month <- MB_toint16(2, ICHEMoffset, data); // 40002 int
    ICHEM.ICHEM_day <- MB_toint16(3, ICHEMoffset, data); // 40003 int
    ICHEM.ICHEM_year <- MB_toint16(4, ICHEMoffset, data); // 40004 int
    ICHEM.ICHEM_hour <- MB_toint16(5, ICHEMoffset, data); // 40005 int
    ICHEM.ICHEM_min<- MB_toint16(6, ICHEMoffset, data); // 40006 int
    ICHEM.ICHEM_sec <- MB_toint16(7, ICHEMoffset, data); // 40007 int
    
    ICHEM.ICHEM_last_flow_meter_cal_month <- MB_toint16(8, ICHEMoffset, data); // 40008 int
    ICHEM.ICHEM_last_flow_meter_cal_day <- MB_toint16(9, ICHEMoffset, data); // 40009 int
    ICHEM.ICHEM_last_flow_meter_cal_year <- MB_toint16(10, ICHEMoffset, data); // 40010 int
    
    ICHEM.ICHEM_MB_cycles_freq_bitmap <- MB_toint16(14, ICHEMoffset, data); // 40014 int
    
    ICHEM.ICHEM_last_cycle_freq_change_year  <- MB_toint16(15, ICHEMoffset, data); // 40015 int
    ICHEM.ICHEM_last_cycle_freq_change_month  <- MB_toint16(16, ICHEMoffset, data); // 40016 int
    ICHEM.ICHEM_last_cycle_freq_change_day <- MB_toint16(17, ICHEMoffset, data); // 40017 int

    ICHEM.ICHEM_last_flow_meter_check_year <- MB_toint16(18, ICHEMoffset, data); // 40018 int
    ICHEM.ICHEM_last_flow_meter_check_month <- MB_toint16(19, ICHEMoffset, data); // 40019 int
    ICHEM.ICHEM_last_flow_meter_check_day <- MB_toint16(20, ICHEMoffset, data); // 40020 int
    
    ICHEM.ICHEM_last_volume_change_year <- MB_toint16(21, ICHEMoffset, data); // 40021 int
    ICHEM.ICHEM_last_volume_change_month <- MB_toint16(22, ICHEMoffset, data); // 40022 int
    ICHEM.ICHEM_last_volume_change_day <- MB_toint16(23, ICHEMoffset, data); // 40023 int
    
    ICHEM.ICHEM_completed_daily_cycles <- MB_toint16(24, ICHEMoffset, data); // 40024 int
    ICHEM.ICHEM_pumped_daily_cycles <- MB_toint16(25, ICHEMoffset, data); // 40025 int
    
    ICHEM.ICHEM_manual_mode_entry_year <- MB_toint16(26, ICHEMoffset, data); // 40026 int
    ICHEM.ICHEM_manual_mode_entry_month <- MB_toint16(27, ICHEMoffset, data); // 40027 int
    ICHEM.ICHEM_manual_mode_entry_day <- MB_toint16(28, ICHEMoffset, data); // 40028 int
    
/*    
    foreach (key, val in ICHEM)
    {
        if(val > -1)
        {
            server.log("agent ICHEM: "+key+": "+val);
        }
    }
*/    
    // put the ICHEM data table in the MB_Device_Data table
    MB_Device_Data.ICHEM <- ICHEM;
} // end of function(data)
); // end device.on(ICHEM_HREG, function(data)


const ICHEM_HREG1 = "iChem_hreg1";
device.on(ICHEM_HREG1, function(data)
{
    server.log("-- agent ICHEM hreg1 data array length: "+data.len());
    if(MB_error_check(data) == 0)
    {
        return; // Found MB data error
    }
    // ICHEM integer data
    const ICHEMoffset = 28;
    ICHEM.ICHEM_last_custom_batch_year <- MB_toint16(29, ICHEMoffset, data); // 40029 int
    ICHEM.ICHEM_last_custom_batch_month <- MB_toint16(30, ICHEMoffset, data); // 40030 int
    ICHEM.ICHEM_last_custom_batch_day <- MB_toint16(31, ICHEMoffset, data); // 40031 int
    
    ICHEM.ICHEM_ext_sys_override_year <- MB_toint16(32, ICHEMoffset, data); // 40032 int
    ICHEM.ICHEM_ext_sys_override_month <- MB_toint16(33, ICHEMoffset, data); // 40033 int
    ICHEM.ICHEM_ext_sys_override_day <- MB_toint16(34, ICHEMoffset, data); // 40034 int
    
    ICHEM.ICHEM_sys_fail_year <- MB_toint16(35, ICHEMoffset, data); // 40035 int
    ICHEM.ICHEM_sys_fail_month <- MB_toint16(36, ICHEMoffset, data); // 40036 int
    ICHEM.ICHEM_sys_fail_day <- MB_toint16(37, ICHEMoffset, data); // 40037 int
    
    ICHEM.ICHEM_battery_alert_year <- MB_toint16(38, ICHEMoffset, data); // 40038 int
    ICHEM.ICHEM_battery_alert_month <- MB_toint16(39, ICHEMoffset, data); // 40039 int
    ICHEM.ICHEM_battery_alert_day <- MB_toint16(40, ICHEMoffset, data); // 40040 int
    ICHEM.ICHEM_battery_alert_hour <- MB_toint16(41, ICHEMoffset, data); // 40041 int
    ICHEM.ICHEM_battery_alert_min <- MB_toint16(42, ICHEMoffset, data); // 40042 int
    
    ICHEM.ICHEM_battery_alarm_year <- MB_toint16(43, ICHEMoffset, data); // 40043 int
    ICHEM.ICHEM_battery_alarm_month <- MB_toint16(44, ICHEMoffset, data); // 40044 int
    ICHEM.ICHEM_battery_alarm_day <- MB_toint16(45, ICHEMoffset, data); // 40045 int
    ICHEM.ICHEM_battery_alarm_hour <- MB_toint16(46, ICHEMoffset, data); // 40046 int
    ICHEM.ICHEM_battery_alarm_min <- MB_toint16(47, ICHEMoffset, data); // 40047 int
    
    ICHEM.ICHEM_low_tank_year <- MB_toint16(48, ICHEMoffset, data); // 40048 int
    ICHEM.ICHEM_low_tank_month <- MB_toint16(49, ICHEMoffset, data); // 40049 int
    ICHEM.ICHEM_low_tank_day <- MB_toint16(50, ICHEMoffset, data); // 40050 int
    
    ICHEM.ICHEM_hi_flow_year <- MB_toint16(51, ICHEMoffset, data); // 40051 int
    ICHEM.ICHEM_hi_flow_month <- MB_toint16(52, ICHEMoffset, data); // 40052 int
    ICHEM.ICHEM_hi_flow_day <- MB_toint16(53, ICHEMoffset, data); // 40053 int
    
    ICHEM.ICHEM_low_flow_year <- MB_toint16(54, ICHEMoffset, data); // 40054 int
    ICHEM.ICHEM_low_flow_month <- MB_toint16(55, ICHEMoffset, data); // 40055 int
    ICHEM.ICHEM_low_flow_day <- MB_toint16(56, ICHEMoffset, data); // 40056 int
    ICHEM.ICHEM_low_flow_hour <- MB_toint16(57, ICHEMoffset, data); // 40057 int
    ICHEM.ICHEM_low_flow_min <- MB_toint16(58, ICHEMoffset, data); // 40058 int
    
    ICHEM.ICHEM_pump_type <- MB_toint16(59, ICHEMoffset, data); // 40059 int
    
    ICHEM.ICHEM_time_based_pump_cycles <- MB_toint16(60, ICHEMoffset, data); // 40060 int
    
/*    
    foreach (key, val in ICHEM)
    {
        if(val > -1)
        {
            server.log("agent ICHEM: "+key+": "+val);
        }
    }
*/    
    // put the ICHEM data table in the MB_Device_Data table
    MB_Device_Data.ICHEM <- ICHEM;
} // end of function(data)
); // end device.on(ICHEM_HREG, function(data)


const ICHEM_HREGfloat = "iChem_hreg_float";
device.on(ICHEM_HREGfloat, function(data)
{
    server.log("-- agent ICHEM float data array length: "+data.len());
    if(MB_error_check(data) == 0)
    {
        return; // Found MB data error
    }
    
    server.log("++++ Daily Vol bytes 0: "+data[0+3]+" 1: "+data[1+3]+" 2: "+data[2+3]+" 3: "+data[3+3]);

/*
    foreach (key, val in data)
    {
       server.log("APG MPX ireg key: "+key+" val: "+val)
    }
*/
    const ICHEMoffset = 98;
    
         // Floats start at 100    
    ICHEM.ICHEM_daily_volume <- MB_tofloat32(100, ICHEMoffset, data); // 40100 float rw
    ICHEM.ICHEM_daily_cycles <- MB_tofloat32(102, ICHEMoffset, data); // 40102 float
    ICHEM.ICHEM_injection_rate <- MB_tofloat32(104, ICHEMoffset, data); // 40104 float
    ICHEM.ICHEM_accum_cycle_vol <- MB_tofloat32(106, ICHEMoffset, data); // 40106 float
    ICHEM.ICHEM_accum_daily_vol <- MB_tofloat32(108, ICHEMoffset, data); // 40108 float
    ICHEM.ICHEM_curr_tank_lev <- MB_tofloat32(110, ICHEMoffset, data); // 40110 float
    ICHEM.ICHEM_fm_k_factor <- MB_tofloat32(112, ICHEMoffset, data); // 40112 float
    ICHEM.ICHEM_yesterday_volume <- MB_tofloat32(114, ICHEMoffset, data); // 40114 float
    ICHEM.ICHEM_week_volume <- MB_tofloat32(116, ICHEMoffset, data); // 40116 float
    ICHEM.ICHEM_month_volume <- MB_tofloat32(118, ICHEMoffset, data); // 40118 float
    ICHEM.ICHEM_year_volume <- MB_tofloat32(120, ICHEMoffset, data); // 40120 float
    ICHEM.ICHEM_forever_volume <- MB_tofloat32(122, ICHEMoffset, data); // 40122 float
    
    ICHEM.ICHEM_custom_batch_volume <- MB_tofloat32(124, ICHEMoffset, data); // 40124 float rw
    ICHEM.ICHEM_remaining_batch_volume <- MB_tofloat32(126, ICHEMoffset, data); // 40126 float
    ICHEM.ICHEM_cycle_countdown <- MB_tofloat32(128, ICHEMoffset, data); // 40128 float
    ICHEM.ICHEM_cycle_duration <- MB_tofloat32(130, ICHEMoffset, data); // 40130 float
    ICHEM.ICHEM_calc_cycle_difference <- MB_tofloat32(132, ICHEMoffset, data); // 40132 float
    ICHEM.ICHEM_adj_target_cycle_volume <- MB_tofloat32(134, ICHEMoffset, data); // 40134 float
    ICHEM.ICHEM_target_cycle_volume <- MB_tofloat32(136, ICHEMoffset, data); // 40136 float
    ICHEM.ICHEM_current_battery_volts <- MB_tofloat32(138, ICHEMoffset, data); // 40138 float
    ICHEM.ICHEM_batch_catch_volume <- MB_tofloat32(140, ICHEMoffset, data); // 40140 float
    ICHEM.ICHEM_dynamic_unit_ratio <- MB_tofloat32(142, ICHEMoffset, data); // 40142 float rw
    ICHEM.ICHEM_dynamic_chem_ratio <- MB_tofloat32(144, ICHEMoffset, data); // 40144 float rw
    ICHEM.ICHEM_dynamic_calc_ratio <- MB_tofloat32(146, ICHEMoffset, data); // 40146 float
    ICHEM.ICHEM_dynamic_rate <- MB_tofloat32(148, ICHEMoffset, data); // 40148 float rw
    ICHEM.ICHEM_dynamic_max_injection_volume <- MB_tofloat32(150, ICHEMoffset, data); // 40150 float rw
    ICHEM.ICHEM_dynamic_min_injection_volume <- MB_tofloat32(152, ICHEMoffset, data); // 40152 float rw
    ICHEM.ICHEM_est_max_pump_output <- MB_tofloat32(154, ICHEMoffset, data); // 40154 float
    ICHEM.ICHEM_production_unit_ext_override_hi_setpoint <- MB_tofloat32(156, ICHEMoffset, data); // 40156 float rw
    ICHEM.ICHEM_production_unit_ext_override_lo_setpoint <- MB_tofloat32(158, ICHEMoffset, data); // 40158 float rw
/*    
    foreach (key, val in ICHEM)
    {
        if(val > -1)
        {
 //           server.log("agent ICHEM float: "+key+": "+val);
        }
    }
*/    
    // put the ICHEM data table in the MB_Device_Data table
    MB_Device_Data.ICHEM <- ICHEM;
} // end of function(data)
); // end device.on(ICHEM_HREG, function(data)

const ICHEM_HREGfloat1 = "iChem_hreg_float1";
device.on(ICHEM_HREGfloat1, function(data)
{
    server.log("-- agent ICHEM float1 data array length: "+data.len());
    if(MB_error_check(data) == 0)
    {
        return; // Found MB data error
    }
/*
    foreach (key, val in data)
    {
       server.log("APG MPX ireg key: "+key+" val: "+val)
    }
*/
    const ICHEMoffset = 130;
    
         // Floats start at 100    
/*
    ICHEM.ICHEM_daily_volume <- MB_tofloat32(100, ICHEMoffset, data); // 40100 float rw
    ICHEM.ICHEM_daily_cycles <- MB_tofloat32(102, ICHEMoffset, data); // 40102 float
    ICHEM.ICHEM_injection_rate <- MB_tofloat32(104, ICHEMoffset, data); // 40104 float
    ICHEM.ICHEM_accum_cycle_vol <- MB_tofloat32(106, ICHEMoffset, data); // 40106 float
    ICHEM.ICHEM_accum_daily_vol <- MB_tofloat32(108, ICHEMoffset, data); // 40108 float
    ICHEM.ICHEM_curr_tank_lev <- MB_tofloat32(110, ICHEMoffset, data); // 40110 float
    ICHEM.ICHEM_fm_k_factor <- MB_tofloat32(112, ICHEMoffset, data); // 40112 float
    ICHEM.ICHEM_yesterday_volume <- MB_tofloat32(114, ICHEMoffset, data); // 40114 float
    ICHEM.ICHEM_week_volume <- MB_tofloat32(116, ICHEMoffset, data); // 40116 float
    ICHEM.ICHEM_month_volume <- MB_tofloat32(118, ICHEMoffset, data); // 40118 float
    ICHEM.ICHEM_year_volume <- MB_tofloat32(120, ICHEMoffset, data); // 40120 float
    ICHEM.ICHEM_forever_volume <- MB_tofloat32(122, ICHEMoffset, data); // 40122 float
    
    ICHEM.ICHEM_custom_batch_volume <- MB_tofloat32(124, ICHEMoffset, data); // 40124 float rw
    ICHEM.ICHEM_remaining_batch_volume <- MB_tofloat32(126, ICHEMoffset, data); // 40126 float
    ICHEM.ICHEM_cycle_countdown <- MB_tofloat32(128, ICHEMoffset, data); // 40128 float
    ICHEM.ICHEM_cycle_duration <- MB_tofloat32(130, ICHEMoffset, data); // 40130 float
  */  
    
    ICHEM.ICHEM_calc_cycle_difference <- MB_tofloat32(132, ICHEMoffset, data); // 40132 float
    ICHEM.ICHEM_adj_target_cycle_volume <- MB_tofloat32(134, ICHEMoffset, data); // 40134 float
    ICHEM.ICHEM_target_cycle_volume <- MB_tofloat32(136, ICHEMoffset, data); // 40136 float
    ICHEM.ICHEM_current_battery_volts <- MB_tofloat32(138, ICHEMoffset, data); // 40138 float
    ICHEM.ICHEM_batch_catch_volume <- MB_tofloat32(140, ICHEMoffset, data); // 40140 float
    ICHEM.ICHEM_dynamic_unit_ratio <- MB_tofloat32(142, ICHEMoffset, data); // 40142 float rw
    ICHEM.ICHEM_dynamic_chem_ratio <- MB_tofloat32(144, ICHEMoffset, data); // 40144 float rw
    ICHEM.ICHEM_dynamic_calc_ratio <- MB_tofloat32(146, ICHEMoffset, data); // 40146 float
    ICHEM.ICHEM_dynamic_rate <- MB_tofloat32(148, ICHEMoffset, data); // 40148 float rw
    ICHEM.ICHEM_dynamic_max_injection_volume <- MB_tofloat32(150, ICHEMoffset, data); // 40150 float rw
    ICHEM.ICHEM_dynamic_min_injection_volume <- MB_tofloat32(152, ICHEMoffset, data); // 40152 float rw
    ICHEM.ICHEM_est_max_pump_output <- MB_tofloat32(154, ICHEMoffset, data); // 40154 float
    ICHEM.ICHEM_production_unit_ext_override_hi_setpoint <- MB_tofloat32(156, ICHEMoffset, data); // 40156 float rw
    ICHEM.ICHEM_production_unit_ext_override_lo_setpoint <- MB_tofloat32(158, ICHEMoffset, data); // 40158 float rw
/*    
    foreach (key, val in ICHEM)
    {
        if(val > -1)
        {
            server.log("agent ICHEM float1: "+key+": "+val);
        }
    }
*/    
    // put the ICHEM data table in the MB_Device_Data table
    MB_Device_Data.ICHEM <- ICHEM;
} // end of function(data)
); // end device.on(ICHEM_HREG, function(data)


const ICHEM_coils = "iChem_coils";
device.on(ICHEM_coils, function(a)
{
/*
    foreach (key, val in a)
        {
            server.log("Time Mark Coil key: "+key+" val: "+val)
        }
*/
    if(MB_error_check(a) == 0)
    {
        return; // Found MB data error
    }

        server.log("-- ICHEM Coils found: "+a[2]+"; Coil Value: "+a[3]);
        

        // Get coil bits
        // bits are in bytes in the a array
        // bits must be shifted off of each byte
        local count = a[2];
        local bits = array(40);
        for(local cnt = 0; cnt < count; cnt++)
        {
            local byte = a[3 + cnt]; // grab the byte
            for(local i = 0; i < 8; i++) // go thru bits
            {
                bits[i+(cnt*8)] = (byte >> i) & 0x01;
            }
        }
        
        ICHEM.ICHEMcoil_Manual_Mode = bits[0];	// coil 10000
	    ICHEM.ICHEMcoil_Start_Pump = bits[1];	// coil 10001
    	ICHEM.ICHEMcoil_Pump_Status = bits[2];	// coil 10002
    	ICHEM.ICHEMcoil_Low_Flow_Alarm_Disabled = bits[3];	// coil 10003
    	ICHEM.ICHEMcoil_Low_Flow_Alarm_Active = bits[4];	// coil 10004
    	ICHEM.ICHEMcoil_Low_Flow_Alarm_Reset = bits[5];	// coil 10005
    	ICHEM.ICHEMcoil_Reset_Yesterday_Vol = bits[6];	// coil 10006
	    ICHEM.ICHEMcoil_Reset_Week_Vol = bits[7];	// coil 10007
    	ICHEM.ICHEMcoil_Reset_Month_Vol = bits[8];	// coil 10008
    	ICHEM.ICHEMcoil_Reset_Year_Vol = bits[9];	// coil 10009
    	ICHEM.ICHEMcoil_Reset_Forever_Vol = bits[10];	// coil 10010
    	ICHEM.ICHEMcoil_Reserved = bits[11];	// coil 10011
    	ICHEM.ICHEMcoil_Set_1_Min_Cycle_Freq = bits[12];	// coil 10012
    	ICHEM.ICHEMcoil_Set_15_Min_Cycle_Freq = bits[13];	// coil 10013
    	ICHEM.ICHEMcoil_Set_30_Min_Cycle_Freq = bits[14];	// coil 10014
    	ICHEM.ICHEMcoil_Set_1_Hour_Cycle_Freq = bits[15];	// coil 10015
    	ICHEM.ICHEMcoil_Set_6_Hr_Cycle_Freq = bits[16];	// coil 10016
    	ICHEM.ICHEMcoil_Set_12_Hr_Cycle_Freq = bits[17];	// coil 10017
    	ICHEM.ICHEMcoil_Set_Daily_Cycle_Freq = bits[18];	// coil 10018
    	ICHEM.ICHEMcoil_Start_Custom_Batch = bits[19];	// coil 10019
    	ICHEM.ICHEMcoil_Stop_Custom_Batch = bits[20];	// coil 10020
    	ICHEM.ICHEMcoil_Low_Tank_Alert = bits[21];	// coil 10021
    	ICHEM.ICHEMcoil_Low_Battery_Alert = bits[22];	// coil 10022
    	ICHEM.ICHEMcoil_Low_Battery_Alarm = bits[23];	// coil 10023
    	ICHEM.ICHEMcoil_Low_Battery_Alarm_Reset = bits[24];	// coil 10024
    	ICHEM.ICHEMcoil_Digital_Output_Interface_Enabled = bits[25];	// coil 10025
    	ICHEM.ICHEMcoil_External_Override_Enabled = bits[26];	// coil 10026
    	ICHEM.ICHEMcoil_External_Override_Active = bits[27];	// coil 10027
    	ICHEM.ICHEMcoil_Hi_Flow_Alarm_Active = bits[28];	// coil 10028
    	ICHEM.ICHEMcoil_Start_Batch_Catch = bits[29];	// coil 10029
    	ICHEM.ICHEMcoil_Dynamic_Flow_Enabled = bits[30];	// coil 10030
    	ICHEM.ICHEMcoil_Dynamic_Max_Flow_Enabled = bits[31];	// coil 10031
    	ICHEM.ICHEMcoil_Dynamic_Min_Flow_Enabled = bits[32];	// coil 10032
    	ICHEM.ICHEMcoil_Production_Unit_External_Override_HI_Enalbed = bits[33];	// coil 10033
    	ICHEM.ICHEMcoil_Production_Unit_External_Override_LO_Enalbed = bits[34];	// coil 10034
    	ICHEM.ICHEMcoil_Production_Unit_External_Override_HI_Status = bits[35];	// coil 10035
    	ICHEM.ICHEMcoil_Production_Unit_External_Override_LO_Status = bits[36];	// coil 10036
    	ICHEM.ICHEMcoil_Recovery_with_Time_on_Low_Flow_Alarm_Enabled = bits[37];	// coil 10037
    	ICHEM.ICHEMcoil_Recovery_with_Time_on_Low_Flow_Alarm_Status = bits[38];	// coil 10038
/*       
        // dump bits
        foreach(key, val in bits)
        {
            server.log("-- coil bits: key: "+key+"; val: "+val);
        }
*/        
//        TimeMark_140127.MB_Comm_Mode = bits[3];
        
    // put the ICHEM data table in the MB_Device_Data table
    MB_Device_Data.ICHEM <- ICHEM;
    
} // end of function(data)
); // end device.on(TIME_MARK_JAN14_coils, function(data)


// Get meta data from the device, which includes the
// impID and ssid information

//  meta key: ssid val: FrankBraswellsPhone5s
//  meta key: devid val: 235c87eb6e4936ee
device.on("metadata", function(data)
    {

        foreach (key, val in data)
        {
            server.log("meta key: "+key+" val: "+val);
        }

        // stash the imp ID for later use
        IMP_DEV_ID <- data.devid; 
        IMP_SSID <- data.ssid;
        getXivelyFeedsTable();
    }
);  // device.on("metadata", function(data)

// Get table data from device and form a csv file
device.on("tabledata",function(data)
    {
    //  First make sure that IMP_DEV_ID is defined
    //  If not, get the information from the Imp
    // This situation can happen during development when
    // the agent code is updated, but the device code
    // doesn't change    
    if(IMP_DEV_ID == "no Imp dev id yet")
    {
        server.log("Don't have Imp dev id");
        local obj = 0;
        // See if I can catch it here - Imp must not be sleeping
//        device.send("getImpInfo", obj);  // Request Information
        device.onconnect(function() 
        {
            device.send("getImpInfo", obj);  // Request Information
            server.log("Request Imp dev id"); 
        });
        return;
    } else
    {
        // Since device.onconnect stays active and executes with
        // each connect, it is necessary to reset it at disconnect time.
        // At disconnect time, turn off the device.onconnect procedure
        // so the device.send("getImpInfo", obj) doesn't keep running
        device.ondisconnect(function()
        {
            device.onconnect(function(){});
        });
    }    
        
        local makecsv = ""; // used to build csv file for Xively
        local report_MB = ""; // MB for log report decoded by device
        
        local report_pvoltest = ""; // for log report
        local report_data = "";  // for log report
        local keys = [ ];
        local bootcount = data.bootcount;
        
        foreach (key, val in data)
        {
            keys.push(key);
        }
        // sorting the keys makes the list easier to read
        keys.sort();
//        server.log("++++++++keys length: "+keys.len());

        foreach (key in keys)
        {
//            server.log("+++++ key: "+key);
            local val = data[key];
                // regexp for number key - indicates pvoltest
            local exp_num = regexp(@"(^\d+)");
                // regexp for Modbus key - string includes "_"
            local exp_mb = regexp(@"(\w+_\w+)");
            
            if (exp_num.capture(key))
            {
                // found number key
//                server.log("pvolttest key: "+key+"; value "+val);
                 
/*                
pvolttest key: 1417952860; value 0.53342
pvolttest key: 1417952870; value 0.554026
*/
                    // build time string
                local v = key.tointeger() - data["time"];
                local t = date(key.tointeger());
                local tformat = format("%4d-%02d-%02dT%02d:%02d:%02d", 
                                        t.year, t.month + 1, t.day, t.hour, t.min, t.sec);
// debug               server.log("table key: "+key+", val: "+val+" - time diff: "+v+" time: "+tformat);
                    // build csv entry with name of chan, time, data value
                makecsv += "pvolttest, "+tformat+", "+val+"\n";
                    // list of pvoltest info
                report_pvoltest += "pvolttest, "+tformat+", "+val+"\n";
                
            } else 
            {
                // all other keys
//                server.log("other key: "+key+"; value "+val);
                
                // list of other data
                    // place other data in report_data string
/*                    
                    if (key.find("wakewhy") != null)
                    {   // wakewhy is a numeric code 1 - 8
                        // look up the string in the table
                        val = val + ": " + impWakeCodes[val];
                    }
*/                    
                    report_data += key+", "+val+"\n";
                    makecsv += key+", "+val+"\n";
            }
            
            // now check for any Modbus data
            
            // check contents of MB_Device_Data table for entries not null
            foreach (key, val in MB_Device_Data)
            {
                if(val)
                {
                    // Found table of Modbus entries
//                    server.log("-- Table: "+key);
                    foreach(k, v in val)
                    {
                         // if bootcount == 0, dump all variables
                        // else dump selected variables listed in MB_Each_time
                        if(bootcount != 0)
                        {
                            // only store variables listed in MB_Each_time
                            if(k in MB_Each_time)
                            {
                                // Dump Modbus table
//                                server.log("MB key: "+k+"; val: "+v);
                                // put MB info in report_MB string
                                report_MB += k+", "+v+"\n";
                                makecsv += k+", "+v+"\n";
                            } 
                            
                        } else
                        {
                            // Dump Modbus table
//                            server.log("MB key: "+k+"; val: "+v);
                            // put MB info in report_MB string
                            report_MB += k+", "+v+"\n";
                            makecsv += k+", "+v+"\n";
                        }
                    } // foreach(k, v in val)
                } //  if(val)
                MB_Device_Data[key] = null; // set back to null for next time
            } // foreach (key, val in MB_Device_Data)
            
        } // foreach (key in keys)

        // Report values to the log
        if(report_pvoltest.len() != 0)
        {
            server.log("--***-- Voltage Channels --***--\n"+report_pvoltest);
        }
        if(report_MB.len() != 0)
        {
            server.log("--***-- Modbus Channels --***--\n"+report_MB);
        }

        if(report_data.len() != 0)
        {
            server.log("--***-- Data Channels --***--\n"+report_data);
        }
        server.log("--***-- End Channels --***--\n");

            // DEBUG dump csv string
//        server.log("----****----Make CSV:\n"+makecsv);
            // send data to Xively feed
        dataToXively(makecsv);
    }
);  // device.on("tabledata",function(data)

// Prepare the request with a csv payload 
function dataToXively(csv) 
{    
    local XIVELY_API_ENDPOINT = "https://api.xively.com/v2/feeds/"+XIVELY_FEED+".csv";
  local body =  csv;
  local extraHeaders = {
//                        "User-Agent": "xively-Imp-Lib/1.0", 
                        "X-Api-Key": XIVELY_API_KEY,
                        "Authorization": XIVELY_Account_Authorization,
//                        "Content-Type": "text/csv",
//                        "Content-Length": format("%d",body.len())
//                        "Content-Length": body.len()
                        };
  local request = http.put(XIVELY_API_ENDPOINT, extraHeaders, body);
                
    server.log("--> Xively Feed: "+XIVELY_FEED_NAME+
                ", ImpID: "+IMP_DEV_ID+
                ", Network: "+IMP_SSID);
    server.log("--> Package lenth: "+body.len()+
                ", sam per: "+IMP_SAMPLE_PER+
                "s, xmit per: "+IMP_XMIT_PER+"s, "+
                (IMP_MODE?"Pump Mode":"Transducer Mode") );
                
//  server.log("put request: "+request+" extra headers: "+extraHeaders);
  request.sendasync(dataToXivelyResponse);
}   // function dataToXively(csv) 

// This is the completed-request callback function, which logs the
// incoming response's message and status code
function dataToXivelyResponse(response) 
{
    if (response.statuscode == 200)
    {
        return;
    }
        // print message if status code is not 200
    server.log("Status Code Put dataToXively CSV: " + response.statuscode + 
                ", Message: " + (response.body==""?"none":response.body));
}   // function dataToXivelyResponse(response) 

// Get Xively/Imp connection data from a special Xively feed
// called from device.on("metadata", function(data)
function getXivelyFeedsTable()
{
        // This is the feed URL for the Xively Feeds Table
    local url = "https://api.xively.com/v2/feeds/1879147064";
//    local xively_apikey = "rOSourU7osPHSsLzveclcZGjVwhLek0GMhUPVhTfWwsMwY6v";  
    local extraHeaders = {
                        "X-Api-Key": "rOSourU7osPHSsLzveclcZGjVwhLek0GMhUPVhTfWwsMwY6v",
//                        "User-Agent":"xively-Imp-Lib/1.0", 
//                        "Content-Type":"text/csv",
//                        "Authorization": "Basic a25pZ2h0aGF3azprbmlnM3QzOHdr"
                        "Authorization": XIVELY_Account_Authorization,
                        };
        // Set up the get request
    local request = http.get(url, extraHeaders);
//    request.sendasync(processResponseFeeds);
        // Make the request
    local response = request.sendsync();
        // Process the response
    getXivelyFeedsTableResponse(response);
    
}   // function getXivelyFeedsTable()

// This is the completed-request callback function, which logs the
// incoming response's message and status code
function getXivelyFeedsTableResponse(response) 
{
//    server.log("Status Code Xively Feeds: " + response.statuscode + ", Message: " + 
//                (response.body==""?"none":response.body.slice(0,25)+"..."));
                
    // In the Special Xively Feed, under the description meta data field
    // there are a group of lines such as the following.
    // Each line contains a comma delimited fields that identify
    
    // impID, Xively feed name, feed id and feed api key.

//    ImpID,       XivelyName,  XivelyFeed,      XivelyApiKey
//  anyimp, SpecialData,   1879147064, rOSourU7osPHSsLzveclcZGjVwhLek0GMhUPVhTfWwsMwY6v
//  235e9deb6e4936ee, WM235e9,   1932829324, 8HqPPy2ymRbzqZhT2TtdWM5h193oJmf8uQhoSdvtfxc9bAYA
//  23219ab236a7c9ee, WM23219, 343437348, WlnQANSpdLKnerPxm62yhaxVVwEojtBjQT0Okru4zt7WDKwh
    
    // The goal here is to search through the lines with the imp ID (IMP_DEV_ID),
    // find the line that starts with the imp ID, isolate the line, and
    // split the line into the components.
    
    // take apart the response body and find Xively info
    // First json decode the line. The data we are looking for
    // is in the data.description string object
    local data = http.jsondecode(response.body);
        // match the line with the Imp DeviceID
        // define a regex to look for the dev ID at the beginning
        // of a line
//    local match = @"("+IMP_DEV_ID+@".*\n)"; // regex string defined
        // Removed the \n and the expression started working again
//    local match = @"("+IMP_DEV_ID+@".*)"; // regex string defined
        // does not match \n correctly
//    local match = "("+IMP_DEV_ID+@".*\n)"; // regex string defined
    local match = "("+IMP_DEV_ID+@".*)"; // regex string defined
    server.log("-- match string: "+match);
        // compile the regex
    local ex = regexp(match);
        // apply the regular expression
    local result = ex.capture(data.description);
    local xivelyInfo; // array for Xively name, feed and api key
        // xivelyInfo[0] = ImpID
        // xivelyInfo[1] = XivelyName
        // xivelyInfo[2] = XivelyFeed
        // xivelyInfo[3] = XivelyApiKey
    
        // if the regular expression returns null, there is no match
    if (result == null)
    {
        server.log("--result == null: no match in: "+data.description);
        return;
    }
            // if here, regular expression matched
            // Next, grab the line with the imp ID and 
            // split out the Xively feed information
            
            // result contains an array of tables with
            // the begin and end position
            // values for the match
            
//    server.log("search results for Imp-Xively Table: "+data.description.slice(result[0].begin,result[0].end));
        // slice gets the string with imp ID
        // split breaks the string apart by commas
        // This gives an array with the following elements:
        // impID,           Xively feed name,   feed id and feed api key.
        // 235c87eb6e4936ee, PowerTest01,       2107508645, iKZLtPhqDBWssrASLyNyot8n1pUc5pshqOZlCgqlip0WH0je
    xivelyInfo = split(data.description.slice(result[0].begin,result[0].end),", ");

//    xivelyInfo[0] - Imp ID
//    xivelyInfo[1] - Name of Xively Feed
//    xivelyInfo[2] - Feed ID
//    xivelyInfo[3] - API Key
//    server.log("Imp-Xively Table Info: Imp ID: "+xivelyInfo[0]+" Feed Name: "+xivelyInfo[1]+
//                " Feed ID: "+xivelyInfo[2]+" API key: "+xivelyInfo[3]);
                
    server.log("Imp-Xively Table Info: Imp ID: "+xivelyInfo[0]+" Feed Name: "+xivelyInfo[1]+
                " Feed ID: "+xivelyInfo[2]);
        
        // strip gets rid of whitespace at the beginning and end of the string - needed 
        // to get rid of new line
    IMP_DEV_ID  = strip(xivelyInfo[X_IMP_DEV_ID]);
    XIVELY_FEED_NAME = strip(xivelyInfo[X_XIVELY_FEED_NAME]);
    XIVELY_FEED = strip(xivelyInfo[X_XIVELY_FEED]);
    XIVELY_API_KEY = strip(xivelyInfo[X_XIVELY_API_KEY]);
    
    try // see if any of these are in the array
    {
        IMP_SAMPLE_PER = strip(xivelyInfo[X_IMP_SAMPLE_PER]).tofloat();
        IMP_XMIT_PER = strip(xivelyInfo[X_IMP_XMIT_PER]).tofloat();
        IMP_MODE = strip(xivelyInfo[X_IMP_MODE]).tointeger(); // MOTOR or TRANSDUCER mode
        
        IMP_ANALOG1_THRESHOLD = strip(xivelyInfo[X_IMP_ANALOG1_THRESHOLD]).tofloat();
        IMP_ANALOG1_RANGE = strip(xivelyInfo[X_IMP_ANALOG1_RANGE]).tofloat();
        
    }  catch (e) 
    {
        // We don't care if it fails because default values will be there
    }

        // These should be either default values or set in the code above  
/*
    server.log("Imp samples period: "+IMP_SAMPLE_PER);
    server.log("Imp transmit period: "+IMP_XMIT_PER);
    server.log("Operating mode: "+(IMP_MODE?"Pump Mode":"Transducer Mode"));
    server.log("Analog1 threhold: "+IMP_ANALOG1_THRESHOLD);
    server.log("Analog1 range: "+IMP_ANALOG1_RANGE);
*/    
    local vars = { "IMP_SAMPLE_PER" : IMP_SAMPLE_PER,
                    "IMP_XMIT_PER" : IMP_XMIT_PER,
                    "IMP_MODE" : IMP_MODE,
                    "IMP_ANALOG1_THRESHOLD" : IMP_ANALOG1_THRESHOLD,
                    "IMP_ANALOG1_RANGE" : IMP_ANALOG1_RANGE,
                };
                
        // Send information to device
        device.send("impControlVariables", vars );

        // in order to use device.send, the device must not
        // be asleep. If asleep, it never receives the send.
        // To make sure device is awake, use the device.onconnect
        // method to send the device.send request
    device.onconnect(function() 
    {
        // Send information to device
        device.send("impControlVariables", vars );
        server.log("######## Device connected to agent - impControlVariables");
    });

        // Since device.onconnect stays active and executes with
        // each connect, it is necessary to reset it at disconnect time.
        // At disconnect time, turn off the device.onconnect procedure
        // so the device.send(newsetpoint, num) doesn't keep running
    device.ondisconnect(function()
    {
        device.onconnect(function(){});
    });
}   // function getXivelyFeedsTableResponse(response) 

// get the number from the json data package
function getNumFromJSON(requestBody)
{
    local data;
    local datajson;
    data = http.urldecode(requestBody);
        // now decode json to make an object
    datajson = http.jsondecode(data.body);
        // get the value of the new setting from the object
    return datajson.triggering_datastream.value.value;
} // function getNumFromJSON(requestBody)

// convert float to 4 byte array
function getBytesFromFloat(floatnum)
{
    // make sure floatnum is converted to a float
    // before being cast to an int
    local intnum = castf2i(floatnum * 1.0);
    local bytes = [  ]; // 4 byte array
    for(local i=0; i<4; i++)
    {
        bytes.append( intnum & 0x00ff );
        intnum = intnum >> 8;
    }
    return bytes;
} // function getBytesFromFloat(floatnum)

// handle a trigger from Xively
function requestHandler(request, response)
{
//    server.log("++++++++++++++received Xively trigger++++++++++++++++");
    // if it was, send the value of it to the device
    // device.send("cmd1 found: ", request.query["cmd1"]);
    local num = 9;
    local coil_val = 0;
    local data, datajson;
//    local datajson;
    local bytes; // 4 byte array
    local requestQueryCmd = request.query.cmd;
//    if(request.query.cmd.find("Set_ICHEM_daily_volume"))
    if(requestQueryCmd.find("Set_ICHEM_"))
    {
        // get the number from the json data package
        num = (getNumFromJSON(request.body)).tofloat();
        server.log("++++ Trigger: "+requestQueryCmd+"; num: "+num+" ++++");
        bytes = getBytesFromFloat(num);
        server.log("++++ bytes 0: "+bytes[0]+" 1: "+bytes[1]+" 2: "+bytes[2]+" 3: "+bytes[3]);
        device.send(requestQueryCmd, bytes);
        
        // in order to use device.send, the device must not
        // be asleep. If asleep, it never receives the send.
        // To make sure device is awake, use the device.onconnect
        // method to send the device.send request
        device.onconnect(function() 
        {
            device.send(requestQueryCmd, bytes);
            server.log("######## Device connected to agent - set ICHEM values");
        });

        // Since device.onconnect stays active and executes with
        // each connect, it is necessary to reset it at disconnect time.
        // At disconnect time, turn off the device.onconnect procedure
        // so the device.send(newsetpoint, num) doesn't keep running
        device.ondisconnect(function()
        {
            device.onconnect(function(){});
        });
        
    }else if(requestQueryCmd.find("Set_ICHEMcoil"))
    {
        // get the number from the json data package
        coil_val = (getNumFromJSON(request.body));
        server.log("++++ Trigger: "+requestQueryCmd+"; coil val: "+coil_val+" ++++");

        device.send(requestQueryCmd, coil_val);
        
        // in order to use device.send, the device must not
        // be asleep. If asleep, it never receives the send.
        // To make sure device is awake, use the device.onconnect
        // method to send the device.send request
        device.onconnect(function() 
        {
            device.send(requestQueryCmd, coil_val);
            server.log("######## Device connected to agent - set ICHEM values");
        });

        // Since device.onconnect stays active and executes with
        // each connect, it is necessary to reset it at disconnect time.
        // At disconnect time, turn off the device.onconnect procedure
        // so the device.send(newsetpoint, num) doesn't keep running
        device.ondisconnect(function()
        {
            device.onconnect(function(){});
        });
        
    }

    else if (request.query.cmd1.find("go", 1) )
    {
            // decode the url
        data = http.urldecode(request.body);
        // now decode json to make an object
        datajson = http.jsondecode(data.body);
        // get the value of the new setting from the object
        num = datajson.triggering_datastream.value.value;
        
    // **** DEBUG ****//
    // If there is no connect/disconnect, use this    
        device.send("newsetpoint", num);
        server.log("+++++ Trigger Received - Quarts per day: "+num+" +++++");
        // in order to use device.send, the device must not
        // be asleep. If asleep, it never receives the send.
        // To make sure device is awake, use the device.onconnect
        // method to send the device.send request
        device.onconnect(function() 
        {
            device.send("newsetpoint", num);
            server.log("######## Device connected to agent - newsetpoint");
        });

        // Since device.onconnect stays active and executes with
        // each connect, it is necessary to reset it at disconnect time.
        // At disconnect time, turn off the device.onconnect procedure
        // so the device.send(newsetpoint, num) doesn't keep running
        device.ondisconnect(function()
        {
            device.onconnect(function(){});
        });
    } else
    {   // assume message in cmd1 for modem string
        device.send("modem_write", request.query.cmd1);
        server.log("cmd1 found in request.query: "+request.query.cmd1);
    }

try
    {
        // send a response back to whoever made the request
        response.send(200, "OK"); // "200: OK" is standard return message
    }
    catch (ex)
    {
        response.send(500, ("Agent Error: " + ex)); // Send 500 response if error occured
    }
    
}   // function requestHandler(request, response)

    // set up the http request handler
    // for Xively set qpd trigger
http.onrequest(requestHandler);

server.log("---AGENT CODE END---");
    
